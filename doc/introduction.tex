% Be sure to write chapter titles in ALL CAPS
\chapter{\uppercase{INTRODUCTION}}
\thispagestyle{empty}

After the introduction of HTML5 in 2011, and its compelling set of new APIs\cite{hickson2010html5}, Rich Web Applications (RWA) have rapidly gained in popularity.  RWAs differ from the more recent Rich Internet Applications (RIA) in that they don't require proprietary browser plug-ins.  They also differ from traditional request/response web applications in that they typically use a single HTML page and update the view on the client-side instead of building many HTML pages on the server-side.

The concept of a ``rich" in-browser application experience was introduced years earlier with technologies such as Adobe's Flex, Microsoft's Silverlight, and Oracle's JavaFX\cite{lawton2008new}.  Each of these technologies uses proprietary browser add-ons to provide a responsive user interaction and are categorized as Rich Internet Applications (RIA).  These proprietary add-ons provide additional functionalities to the web that were missing before HTML5, but also decreased its openness\cite{vaughan2010}.

Rich Web Applications (RWA) differ from RIAs in that RWAs focus on creating a specific browser independent application without the reliance on any proprietary, client-side browser plug-ins.  Indeed, Ian Hickson, one of the W3Câ€™s HTML5 editors, stated ``one of our goals is to move the Web away from proprietary technologies''\cite{vaughan2010}.

Additionally, there are key differences between traditional web applications and RWAs\cite{paulson2005building}.  First, a traditional web application consists of many static HTML pages or scripts (e.g., JSP or PHP) to render different portions of the site\cite{falkner2001beginning, williams2004web}.  A user of a traditional web application is required to retrieve a full page for each interaction with the application.  Conversely, a RWA typically consists of a single HTML page that acts as an entry point.  This single page entry point contains complex application logic implemented in bundled JavaScript or a collection of JavaScript script files.  This application logic is downloaded on the first HTML entry point page load and is then run on the browser.  A RWA then updates its views by manipulating the Document Object Model (DOM) using HTML composites downloaded with that first page load.  It also retrieves data associated with these components by asynchronously making Ajax requests (i.e., XmlHttpRequest or XHR) to the server.  The server then responds with data in a JSON or XML format.

Along with this architecture change, RWAs have adopted a new URL structure that relies heavily on sometimes complex URL fragments to maintain history and state within the application.  These URLs are sometimes called semantic or clean URLs.  These semantic URLs are much easier for the end-user to understand, describe, and infer site application structure.  While easier for user understanding, semantic URLs pose a significantly more difficult challenge in systematically identifying variables for subsequent testing.

As RWAs adopt the HTML5 strategy of moving away from proprietary technologies, there is also a movement to follow the HTTP protocol as it was designed--- a ``generic, stateless protocol'' \cite{berners1999hypertext}.  This leads to many RWAs being stateless.  A stateless web application has many benefits, including performance, scalability, and simplicity.  Not requiring the expensive overhead of maintaining session information on the server allows for more concurrent users with less infrastructure.  It also allows for the removal of an additional layer of complexity in the production environment by not requiring the replication of session information across multiple nodes.

A RWA architecture provides many benefits.  From a development standpoint, a RWA allows for a clean separation of concerns.  Front-end development and design can be done independent of the back-end services.  Back-end developers can then focus exclusively on building a robust API.  This API can then be made available to both RWAs and other non-web applications, such as native Android or iOS applications.  Perhaps the biggest advantage is that a user is never required to load a new page.  Due to this, and the resulting lack of latency, a RWA feels more responsive or ``rich.''

While end users benefit from the migration of complex application logic from the server to the browser, testing has become more difficult.  Exceptions and coding irregularities no longer occur solely on the server in a convenient, controlled, and centralized location.  Errors now occur in a distributed fashion in various types and versions of browsers, computers, and environments.  As such, a more structured approach to testing needs to move from the server to the client.

The RWA focus on a ``rich'' user experience (i.e., responsive interfaces and interactive capabilities)\cite{paulson2005building}, comes at a price as the ``richness'' increases the importance and cost of testing.  For software testing, much effort has been applied to controlling the cost while still maintaining effective fault discovery.  Research into quality and reliability of software development by Wallace and Kuhn has yielded empirical data that ``suggests that relatively few parameters are actually involved in triggering failures''\cite{kuhn2004software}.  Kuhn et al. reviewed 15 years worth of medical device recall data gathered by the U.S. Food and Drug Administration (FDA).  Working with 109 cases, they determined that 97\% of all reported flaws could be detected by testing all pairs of parameter settings\cite{kuhn2004software}.  Pairwise testing (i.e., two-way testing) combines all interactions between two parameters.  In a separate study, Kuhn et al. also discovered by analyzing the publicly available fault database of the Mozilla Browser, that 76\% of faults were found by two-way testing\cite{kuhn2002investigation}.  The remaining faults were identified with higher ``t-wise'' combination of parameters.  

Colbourn shows that producing higher ``t-wise'' variable combinations is NP Hard\cite{colbourn2004combinatorial}, meaning the number of test cases to perform grows exponentially with higher variable interaction.  This substantial growth in test cases can make exhaustive or higher strength testing impractical and costly.  One strategy to control cost is to reduce the number of tests needed to discover faults.  Due to the heavy use of templates (i.e., reusable snippets of layout and logic) in RWAs, they are a prime candidate for reduction.  Later, I propose a reduction strategy and provide a comparison on the effectiveness of discovering faults on a sample application.

In addition to generating tests that cover interactions, combinatorial based prioritization may improve testing effectiveness by increasing the rate at which faults are detected.  This strategy tests ``more important'' components early in the testing phase.  While outside the scope of this paper, I do mention some ideas for prioritization that could be explored in future research.  Indeed, recent work by Bryce et al. \cite{bryce2007test, bryce2011developing, sampath2008prioritizing}, with two-way inter-window event coverage for event-driven systems, has applicability with RWAs.

Before any combinatorial testing can be performed, a covering array needs to be generated to build the ``t-wise'' combination of variables.  With their single page HTML entry points, and their dynamic, semantic URL fragments, RWAs pose a challenge in identifying variables for the creation of covering arrays.  This thesis will also introduce a novel and practical way to identify variables in semantic URL fragments and demonstrate that combinatorial testing, like in other application types, provides benefit in identifying faults in RWAs on a relatively small test suite.