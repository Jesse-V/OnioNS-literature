
\chapter{\uppercase{Solution}}

\section{Overview}

I propose a new DNS system for Tor hidden services, which I am calling EsgalDNS. \textit{Esgal} is a Sindarin Elvish noun from the works of J.R.R Tolkien, meaning "veil" or "cover that hides".\cite{SindarinDict} EsgalDNS is a distributed DNS system embedded within the Tor network and powered by existing Tor nodes. It exists on top of the existing Tor hidden service infrastructure and is backwards compatible with the current hidden service protocol. EsgalDNS shares some design principles with Namecoin and other DNS systems, and its usage is analogous to the traditional Clearnet DNS system. The system supports a number of command and control operations, known as \textit{records}, including Query, Create, Modify, Move, Renew, and Delete. All records, aside from Query, are authenticated by digital signatures to ensure that only the operator of the hidden service issued them. These commands are processed by a subset of participating Tor nodes, described below.

\section{Components}

\subsection{Cryptographic Primitives}

Our system makes use of cryptographic hash algorithms, digital signatures, and a pseudorandom number generator. As the cryptographic data within our system must persist for many years to come, we select well-established algorithms that we predict will remain strong against cryptographic analysis in the immediate future. In particular importance is the hash algorithm. We choose SHA-384 for most applications for its greater resistance to preimage, collision, and pseudo-collision attacks over SHA-256, which is itself significantly stronger than Tor's default hidden service hash algorithm, SHA-1. Like SHA-512, SHA-384 requires 80 rounds but its output is truncated to 48 bytes rather than the full 64, which saves space. For digital signatures, our default method is EMSA-PSS, (EMSA4) a probabilistic signature scheme defined by PKCS1 v2.1 and republished in 2003's RFC 3447, using a Tor node's 1024-bit RSA key with the SHA-384 digest to form the signature appendix. For signatures inside our proof-of-work scheme, we rely on $EMSA-PKCS1-v1_5$, (EMSA3) defined by 1998's RFC 2315. In contrast to EMSA-PSS, its deterministic nature prevents hidden service operators from bypassing the proof-of-work and brute-forcing the signature to validate the record. Our proof-of-work algorithm is scrypt, a key derivation function which is notable for its large memory and CPU requirements during its operation. In applications that require pseudorandom numbers from a known seed, we use the Mersenne Twister generator. In all instances the Mersenne Twister is initialized from the output of a hash algorithm, negating the generator's weakness of producing substandard random output from certain types of initial seeds.

We use the JSON format to encode records and databases of records. JSON is significantly more compact than XML, but retains readability. Its support of basic primitive types is highly applicable to our needs. Additionally, we consider the JSON format safer than byte-level encoding.

\subsection{Quorum}

EsgalDNS may have many participants: any Tor nodes that has sufficient storage and bandwidth capacity may perform a full synchronization and mirror the complete DNS system. However, only a subset of them must perform the main duties of the system at any given time. EsgalDNS is primarily powered by a special subset of Tor nodes, called a \textit{quorum}. The $ M $ nodes in the quorum may be found deterministically from the signed consensus document published by the Tor authority nodes. This consensus document is generated every hour by the authority nodes and distributed to all Tor nodes and clients. We consider the document published at 00:00 GMT each day; first we take the SHA-384 of the document, then secondly initialize the Mersenne Twister pseudorandom number generator (PRNG) from the output. Third, we construct a numerical list of Tor nodes from the consensus document, and finally scramble that list using the PRNG. The first $ M $ nodes, numbered $ 1 .. M $, become the quorum.

\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[->, >=stealth', shorten >=1pt, auto, node distance=2.5cm,
			thick, main node/.style={circle, fill=blue!20, draw, font=\sffamily\Large\bfseries}]

			\node[main node] (1) {$Q_{1}$};
			\node[main node] (2) [right of=1] {};
			\node[main node] (3) [right of=2] {$Q_{1}$};
			\node[main node] (4) [right of=3] {$Q_{2}$};

			\node[main node] (5) [below of=1] {$Q_{3}$};
			\node[main node] (6) [right of=5] {$Q_{1}$};
			\node[main node] (7) [right of=6] {$Q_{2}$};
			\node[main node] (8) [right of=7] {};
		  
			\node[main node] (9) [below of=5] {};
			\node[main node] (10) [right of=9] {$Q_{3}$};
			\node[main node] (11) [right of=10] {$Q_{2}$};
			\node[main node] (12) [right of=11] {};

			\node[main node] (13) [below of=9] {};
			\node[main node] (14) [right of=13] {};
			\node[main node] (15) [right of=14] {};
			\node[main node] (16) [right of=15] {$Q_{3}$};
		  
			%http://www.texample.net/tikz/examples/tkz-berge/
			%http://www.texample.net/tikz/examples/graph/
			
			\tikzstyle{EdgeStyle}=[bend left, -, dotted]
			\tikzstyle{edge day1} = [draw, thick, -, black, dotted]
			\Edge[](1)(3)
			\draw[edge day1] (3) -- (6);
			
			\tikzstyle{edge day2} = [draw, thick, -, black, dotted]
			\draw[edge day2] (11) -- (7) -- (4);
			
			\tikzstyle{edge day3} = [draw, thick, -, black]
			\draw[edge day3] (5) -- (10) -- (16);

		\end{tikzpicture}
	\caption{Past and present 3-member quorums in a 16-node network, day 3.}
	\label{fig:figure5}
\end{figure}

Since both clients and Tor nodes hold an authenticated and up-to-date copy of the consensus document, all involved parties are aware and agree on the members of the quorum. As we use the document at the beginning of each day, quorum nodes have an effective lifetime of 24 hours before their primary responsibilities are replaced by a new quorum. Since the health and status of the Tor network cannot be easily determined in advance, the quorum cannot be determined or known in advance until the new consensus document is published. This deterministic but unpredictably random nature makes the system more resilient to attackers attempting to force their node into the quorum for malicious purposes. Furthermore, as the digital signature from the authority nodes is embedded within the consensus document itself and all involved parties have the public keys of the authority nodes, past quorums can be securely derived from archives of the consensus document.

\subsection{Page}

A \textit{page} is long-term JSON-encoded textual database held by quorum nodes. It contains five fields, \textit{prevHash}, \textit{recordList}, \textit{consensusDocHash}, \textit{nodeKey}, and \textit{pageSig}. \textit{prevHash} is the SHA-384 hash of \textit{prevHash}, \textit{recordList}, and \textit{consensusDocHash} of a previous page. \textit{recordList} is an array of records, sorted in some globally deterministic manner. \textit{consensusDocHash} is the SHA-384 of the morning's consensus document. \textit{nodeKey} is the public key of the quorum node, which can hashed to find the node's fingerprint in the consensus document, or used directly to verify \textit{pageSig}, the digital signature of the preceding fields.

Each quorum node holds its page, the pages of the other quorum nodes on that day, and an archive of the consensus document. To generate its page, it first picks a page from the past quorums by the following method:

%according to the following criteria

\begin{enumerate}
	\item Of all chains of pages in the database, ignore any invalid pages and any pages that form chains using those invalid pages. A page may be invalid if it contains records that do not follow the below specifications, its \textit{consensusDocHash} field does not match the hash of the consensus document on that day, or if \textit{pageSig} does not verify. Invalid pages may suggest that the quorum node was not fully synchronized, that it acted maliciously, or that there was data corruption.
	\item From these valid chains, find the chain that has been used by the largest number of Tor quorum nodes (not counting today's quorum) and choose the most recent page.
	\item If there are multiple chains that satisfy the second condition, choose from among them the page that contains the largest amount of records.
	\item If the third condition cannot be resolved, choose from among them the page that is held by the smallest $ i $ in the $ M $ quorum nodes.
\end{enumerate}

It then takes the SHA-384 of \textit{prevHash}, \textit{recordList}, and \textit{consensusDocHash} of that page, forming \textit{prevHash}. Secondly, it generates \textit{consensusDocHash} by hashing the morning's consensus document. Finally, it hashes the page and generates a digital signature of that hash, storing the result in \textit{pageSig}. The usage of \textit{recordList} is described below.

\subsection{Snapshot}

Similar to a page, a \textit{snapshot} is JSON-encoded textual database held by quorum nodes, but unlike pages, snapshots are short-term and volatile. They are used for propagating very new records and receiving records from other quorum nodes, and are only held and processed by quorum nodes in the current day. Snapshots contain three fields: \textit{originTime}, \textit{recentRecords}, and \textit{snapshotSig}, where \textit{originTime} is the timestamp when the snapshot was first created, \textit{recentRecords} is a list of DNS records, and \textit{snapshotSig} is the digital signature of \textit{originTime} and \textit{recentRecords}. When a hidden service operator informs a quorum node about a new record, the quorum node first confirms that the record is valid (described below) and if it is, it adds that record into \textit{recentRecords} and updates \textit{snapshotSig}. 

Where $ S_{x} $ is the current snapshot at propagation iteration $ x $, at each 15 minute mark each active quorum node $ Q_{j} $ performs the following:

\begin{enumerate}
	\item Generates a new snapshot, labelled $ S_{x+1} $, sets \textit{originTime} to the current time, creates \textit{snapshotSig}, and sets $ S_{x+1} $ to be the currently active snapshot for collecting new records.
	\item Randomly selects $ M / 2 $ nodes from the $ M $ quorum nodes, defining \textit{swapSet}.
	\item With each node $ N_{k} $ in \textit{swapSet}, it swaps $ S_{x} $ and \textit{pageSig} with node $ N_{k} $, receiving a snapshot $ R_{x, k} $ and signature $ Sig_{x, k} $, and then verifies the validity of $ R_{x, k} $. For efficiency, if $ N_{k} $ in turn selects $ Q_{i} $, no swap will need to take place.
	\item After all swapping is complete, $ Q_{j} $
		\begin{enumerate}
			\item Archives $ S_{x} $ and each $ R_{x, k} $ and $ Sig_{x, k} $ for all $ k $ in \textit{swapSet}.
			\item Updates its copy of $ N_{k} $'s page by merging in $ R_{x-4, k} $, then confirming that $ Sig_{x, k} $ verifies against the generated page. If not, it asks $ N_{k} $ for its page so that the discrepancy can be resolved.
			\item Updates its page by merging the contents of $ S_{x-4} $ into \textit{recordList} and regenerates \textit{pageSig}.
			\item Deletes $ S_{x-4} $.
		\end{enumerate}
\end{enumerate}


% Page identification? Is 4b right? Need to swap all known snapshots! Delete old snapshots!


\subsection{Synchronization}

Tor nodes must perform a full synchronization with the quorum nodes or node(s) mirroring the database before they are qualified to be picked as part of a quorum. 

 up-t

Tor nodes may optionally synchronize with quorum nodes. They may want to mirror the page-chain database or qualify to be a quorum node themselves. 

\subsection{Registration Query}

\subsection{Registration Creation}

\subsection{Record Modification}

\subsection{Ownership Transfer}

\subsection{Domain Renewal}

\subsection{Registration Deletion}

\subsection{Broadcast}






Nodes currently in the quorum are responsible for handling transactions such as the Create, Modify, Move, Renew, and Delete commands. They can also respond to Query requests, although other nodes can also respond as well. Hidden service operators can use Tor circuits to give one of these former commands to one or more quorum nodes. The transaction then propagate to the remaining quorum nodes when they synchronize their knowledge bases. Each quorum node is responsible for distributing two databases to other quorum nodes: \textit{pages} and \textit{snapshots}. Pages are long-term and stable collections of records, whereas snapshots hold volatile records that may be yet be fully propagate across the entire quorum. Pages reference pages from the previous day's quorum, forming a append-only page-chain that grows forward with time. Snapshots, by contrast, do not reference previous pages but their information is merged into the quorum node's page periodically.




A page on day $ n $ belonging to quorum member $ i $ can be expressed as $ P_{n,i} $. This page contains five distinct elements: \textit{prevN}, \textit{prevI}, \textit{prevHash}, \textit{recordList}, \textit{consensusDoc}, and \textit{digSig}, where \textit{prevN} and \textit{prevI} represents the back-reference to the $ P_{prevN,prevI} $ page, \textit{prevHash} is the SHA-256 of $ P_{prevN,prevI} $, \textit{recordList} is the list of records that were send the quorum on day $ n $, \textit{consensusDoc} is the consensus document digitally signed by the authority nodes, and finally \textit{digSig} is the digital signature from quorum member $ i $ on the preceding fields.

At startup, every Tor node participating in EsgalDNS 







One of the central elements in my system is a \textit{quarum}, a set of special decision-making Tor nodes. The set of committee nodes changes every day and the set cannot be known in advance. 

At a high level, domain registrations are broadcasted through a Tor circuit to all committee nodes. Every node then analyses the registration as well as its knowledge of the chain and makes a decision. If the registration is invalid, the node rejects with an appropriate flag. If the domain name is already taken, the node returns a flag along with the pre-existing registration. Otherwise, it digitally signs its approval and the proposal itself and distributes this to the rest of the committee. It then waits for the rest of the committee votes. Since every Tor node has the up-to-date public keys of all other nodes due to the consensus documents, every committee member can verify the votes of all other committee members. Once the node confirms that all committee nodes received the same proposal and that a significant majority indicate that the domain is both valid and available, it adds the registration to its local storage. More importantly, the registration is recorded to an append-only endless scroll distributed within the Tor network. Thus domain names are consumed in a first-come-first-serve basis.

The scroll is a distributed and highly redundant chained data structure that slowly rolls through the Tor network. The scroll is $ N $ by $ M $ in shape and consists of two primary components: \textit{blocks} and \textit{captures}. Blocks contain one or more captures, and blocks are duplicated across the $ M $ committee nodes. Each capture is a collection of information from one day; it contains the consensus document from the previous morning, a list of domain registrations approved that day, the approval sign-off digital signatures from the committee nodes on those registrations, the digital signatures from the committee indicating their approval of the integrity of the scroll, and the hash of the previous four captures. In this way, captures are fully verifiable and contain enough information to link to the previous capture, forming a chain. This chain is not held by any single Tor node, rather it is encapsulated within a rolling window of blocks $ N $ days deep. As the days progress, the captures in the oldest block are migrated to the current day's block, rolling the structure forward. Thus the scroll is divided across $ N $ blocks, with copies of each block held by $ M $ Tor nodes. I consider $ N = 16, M = 64 $ reasonable values, which would involve 1,024 nodes at any given time, although $ M $ can be easily changed even while the scroll is in use.

This distributed system provides the ability to confirm a given domain name is not already in use, without relying on a single central authority. Assuming that the committee nodes are honest in their vote and trustworthy in their nature, this achieves all three properties of Zooko's Triangle. Even if the committee nodes are malicious, I believe I can introduce sufficient countermeasures to make it infeasible for an attacker to successfully manipulate the system, assuming that the majority of the Tor network is trustworthy. More research, design, and implementation is needed, but this I believe is a very promising approach.


% Each node then votes on the proposed registration. A vote consists of \textit{decision}, \textit{hash}, \textit{count}, \textit{root}, and \textit{signature} where \textit{decision} is either \textit{available}, \textit{unavailable}, or \textit{invalid}; \textit{hash} is the SHA256 of the registration it received; \textit{count} is the number of valid registrations it has in local storage; \textit{root} is the root node of the Merkle tree formed by those registrations; and \textit{signature} is the digital signature of the preceding fields.

% \textit{count} and \textit{root} will both be used to keep nodes synchronized with one another. Although I won't go into detail here, my plan calls for out-of-date nodes to attempt to synchronize with the node that advertises the highest \textit{count}. Synchronization also involves checking the votes, so falsely advertising a high \textit{count} isn't sufficient to mislead the network. \textit{root} is useful because it enables quick verification that nodes have synchronized lists and the use of a Merkle tree in general allows efficient synchronization when a node is out-of-date.

\subsection{Domain Registration}

A domain registration consists of eight components which are tied together by digital signatures and proof-of-work. The components are \textit{nonce}, \textit{consensusHash}, \textit{time}, \textit{domain}, \textit{subdomains}, \textit{contact}, \textit{digSig}, and \textit{pubKey}.

\begin{description}
	\item[nonce] \hfill \\
		An eight-byte number that serves as a source of randomness for the proof-of-work.
	\item[consensusHash] \hfill \\
		A 32-byte value containing the SHA256 hash of the consensus document published by the authority nodes. Consensus documents are generated frequently, so \textit{consensusHash} will be based on the document published at 00:00 GMT that day.
	\item[time] \hfill \\
		A four-byte integer holding the number of seconds since January 1st, 2013.
	\item[domain] \hfill \\
		A null-terminated cstring of the human-meaningful domain that will be correlated with the traditional .onion address of the hidden service. This can be up to 32 characters long. The TLD is .tor
	\item[subdomains] \hfill \\
		Up to 255 bytes of subdomain data, preceded by one byte that indicates the byte length. Each subdomain is null-terminated, so with the null characters 15 subdomains are possible when each is 16 characters long.
	\item[contact] \hfill \\
		16 bytes representing the last 32 base64-encoded bytes of the fingerprint of the service operator's PGP key, if they have one. If they do not, these bytes are zeroed. The purpose of this field is to allow the operator to be contacted securely.
	\item[digSig] \hfill \\
		The digital signature of all preceding fields.
	\item[pubKey] \hfill \\
		The public key of the hidden service.
\end{description}

To generate a registration, \textit{domain}, \textit{subdomains}, and \textit{contact} are determined by the operator, while \textit{consensusHash} and \textit{time} are filled in automatically. The hidden service operator then has to find a value for \textit{nonce} such that the proof-of-work is valid, specifically that that the SHA256 of \textit{digSig} is less than a target value \textit{T}. I plan to set \textit{T} such that the proof-of-works takes a significant amount of time on a modern CPU. This makes registering a domain expensive, thwarting flooding attacks. If \textit{nonce} is found, the registration is valid and ready for broadcast.

Two common proof-of-work systems are hashing, typically double-SHA256 ($ \textrm{SHA}256^{{2}} $) in the case of Bitcoin, and scrypt, a password-based key derivation function used by Litecoin. I chose the latter here; scrypt is a harder proof-of-work system because it requires large quantities of RAM in addition to CPU time, making brute-forcing significantly more challenging. Finding \textit{nonce} is made even more difficult because for every \textit{nonce}, a new digital signature must be made using the service's private key. This slows mining, complicates porting to GPUs and other specialized hardware, and prevents outsourcing to a outside computational resource. The digital signature ensures that all field are authenticated to the key of the hidden service, verifiable by all.

Once created and finalized, domains are broadcasted through Tor circuit(s) to committee nodes, where it can be approved and added into the scroll.

\subsection{Registration Query}

A client requesting \textit{example.tor} can use a Tor circuit to anonymously query committee nodes, or in fact any node holding the scroll, for the domain name. If the domain is taken, the client will receive the full registration (as specified above) as well as the digital signatures of the committee members who voted on that registration. This consensus and the registration itself can both be validated by the client's machine. The client can then extract \textit{pubKey} from the registration, hash it and truncate it, and look up the .onion in the traditional manner.




\section{Fault Tolerance}

Page wrapping stuff...