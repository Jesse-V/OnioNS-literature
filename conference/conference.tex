\documentclass[USenglish,oneside,twocolumn]{article}
\usepackage{etex}

\usepackage[utf8]{inputenc}
\usepackage[big]{dgruyter_NEW}

\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{decorations.text}
\usepackage{tkz-berge}
\usepackage{amsfonts}
\usepackage{natbib}

% these packages may not be needed
%\usepackage[urlbordercolor={1 1 1},citebordercolor={1 1 1},linkbordercolor={1 1 1}]{hyperref}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{tabularx}

%todo
%\DOI{foobar}

\cclogo{\includegraphics{by-nc-nd.pdf}}

% https://tex.stackexchange.com/questions/42271/floor-and-ceiling-functions
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\newcommand*\concat{\mathbin{\|}}
\newcommand*\nWinners{\left\vert{W_{i}}\right\vert}
  
\begin{document}

\author[1]{Anonymized Submission}
%\author[1]{Jesse Victors}
%\author[2]{Ming Li}
%\author[3]{Xinwen Fu}

%\affil[1]{Utah State University \newline \hspace{2em} E-mail: jvictors@jessevictors.com}
%\affil[2]{University of Arizona \newline \hspace{2em} E-mail: lim@email.arizona.edu}
%\affil[3]{University of Massachusetts Lowell \newline \hspace{2em} E-mail: xinwenfu@cs.uml.edu}

\title{\huge The Onion Name System \large \\ Tor-powered Distributed DNS for Tor Hidden Services}
%\subtitle{Tor-powered Distributed DNS for Tor Hidden Services}
\runningtitle{The Onion Name System -- Tor-powered Distributed DNS for Tor Hidden Services}

\begin{abstract} {
Tor hidden services are anonymous servers of unknown location and ownership which can be accessed through any Tor-enabled web browser. They have gained popularity over the years, but since their introduction in 2002 still suffer from major usability challenges primarily due to their cryptographically-generated non-memorable addresses. \newline \hspace*{1em} In response to this difficulty, in this work we introduce the Onion Name System (OnioNS), a privacy-enhanced distributed resolution service. OnioNS allows Tor users to reference a hidden service by a meaningful globally-unique verifiable domain name chosen by the hidden service operator. We construct OnioNS as an optional backwards-compatible plugin for Tor, simplify our design and threat model by embedding OnioNS within the Tor network, and provide mechanisms for authenticated denial-of-existence with minimal networking costs. We also introduce a lottery-like system to reduce the threat of land rushes and domain squatting. Finally, we integrate our client software with the Tor Browser and conduct performance analysis of our prototype. %find that the Tor Browser can load a hidden service under a meaningful domain name in approximately YYY seconds above baseline.
}
\end{abstract}
  
%\keywords{keywords, keywords} %todo?
%\classification[PACS]{}
%\communicated{...}
%\dedication{...}

%todo
\journalname{Proceedings on Privacy Enhancing Technologies}
%\DOI{Editor to enter DOI}
%\startpage{1}
%\received{..}
%\revised{..}
%\accepted{..}

\journalyear{2015}
\journalvolume{2015}
\journalissue{2}
 
\maketitle

\section{Introduction}

As the prevalence of the Internet and other communication has grown, so too has the development and usage of privacy-enhancing systems. These are protocols that provide privacy by obfuscating the link between a user's identity or location and their communications. Following a general distrust of unsecured Internet communications and in light of the 2013-current revelations by Edward Snowden of international Internet mass-surveillance, users have increasingly turned to these tools for their own protection.
\newpage
Tor \cite{dingledine2004tor} is a third-generation onion routing system and is the most popular low-latency anonymous communication network in use today. In Tor, users construct a layered encrypted communications circuit over three onion routers in order to mask their identity and location. As messages travel through the circuit, each onion router in turn decrypts their encryption layer, exposing their respective routing information. The first router is only exposed to the user's IP address, while the last router conducts Internet activities on the user's behalf. This provides end-to-end communication confidentiality of the sender.

%The Tor network is managed by set of nine directory authorities, spread out across geographically diverse locations. Once per hour, the directory authorities vote on the state of the network and redistribute routing information to all relays and clients, forming a PKI and a information

Tor users interact with the Internet and other systems over Tor via the Tor Browser, a security-enhanced fork of Firefox ESR. This achieves a level of usability but also security: Tor achieves most of its application-level sanitization via privacy filters in the Tor Browser; unlike its predecessors, Tor performs little sanitization itself. Tor's threat model assumes that the capabilities of adversaries are limited to traffic analysis attacks on a restricted scale; they may observe or manipulate portions of Tor traffic, that they may run onion routers themselves, and that they may compromise a fraction of other existing routers. Tor's design centers around usability and defends against these types of attacks.

\subsection{Motivation}

Tor also supports \emph{hidden services} -- anonymous servers that intentionally mask their IP address through Tor circuits. They utilize the .onion pseudo-TLD, typically preventing hidden services from being accessed outside the context of Tor. Hidden services are only known by their public RSA key and typically referenced by their address, 16 base32-encoded characters derived from the SHA-1 hash of the server's key, i.e. \url{3g2upl4pq6kufc4m.onion}. This builds a publicly-confirmable one-to-one relationship between the public key and its address and allows hidden services to be accessed via the Tor Browser by their .onion address within a distributed environment.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.9\linewidth]{../assets/images/LucidCharts/Hidden_Services.pdf}
	\caption{A Tor client, Alice, and a hidden service, Bob, first mate two Tor circuits (purple and red) at one of Bob's long-term \emph{introduction points} (IP). They then renegotiate and communicate over another pair of Tor circuits (blue and green) at an ephemeral \emph{rendezvous point} (RP). This achieves communication with bi-directional anonymity \cite{overlier2006locating}.}
\end{figure}

Tor hidden service addresses are distributed and globally collision-free, but there is a strong discontinuity between the address and the service's purpose. As their addresses usually contain no human-readable information, a visitor cannot categorize, label, or authenticate hidden services in advance. While a Tor user may explore and bookmark hidden services within the Tor Browser, this is a very narrow solution and does not scale well past a few dozen bookmarks. Over time, third-party directories -- both on the clearnet and darknet -- have appeared in an attempt to counteract this issue, but these directories must be constantly maintained and the approach is neither convenient nor does it practically scale past several hundred entries. The approximately 27,000 hidden services currently on the Tor network (Figure \ref{fig:OnionCount}) and the potential for continued growth both suggest the strong need for a more complete and wider solution to solve the usability issue.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{../assets/images/Tor/onion_2015-02_2015-07.eps}
	\caption{The number of unique .onion addresses seen in the Tor network between February 2015 and July 2015 \cite{kadianakis2015extrapolating, TorMetrics}.}
	\label{fig:OnionCount}
\end{figure}

\subsection{Contributions}

In this paper, we present the design, analysis, and implementation of the Onion Name System, (OnioNS) a distributed, secure, and usable domain name system for Tor hidden services. Any hidden service can claim a meaningful human-readable domain name without loss of anonymity and clients can query against OnioNS in privacy-enhanced and verifiable manner. OnioNS is powered by a random subset of nodes within the existing Tor network, significantly limiting the additional attack surface. We devise a distributed database that is resistant to node compromise and provides authenticated denial-of-existence. We provide a backwards-compatible plugin for the Tor Browser and demonstrates the high usability and performance of OnioNS. To the best of our knowledge, this is the first alternative DNS for Tor hidden services which is distributed, secure, and usable at the same time.

\textbf{Paper Organization:} This paper is divided into four main sections. In section \ref{sec:problemStatement} we define our design objectives and explain why existing works do not meet our goals. We also define our threat model, which includes Tor's assumptions and the capabilities of our adversaries. In section \ref{sec:Solution}, we describe the system overview and define several key protocols. In section \ref{sec:Analysis} we analyse the security of our assumptions and examine other attack vectors. Last, in section \ref{sec:Evaluation} we describe our implementation prototype, perform performance analysis tests, and demonstrate that our software allows the Tor Browser to load a hidden service under a meaningful domain name.

\section{Problem Statement}
\label{sec:problemStatement}

To integrate with Tor, we must provide a secure system, preserve user privacy, and avoid compromising other areas of the Tor network. Additionally, we seek to achieve all three properties of Zooko's Triangle (section \ref{sec:ZookosTriangle}) and to providing a mechanism for authenticated denial-of-existence (section \ref{sec:authDenialIntro}).

\subsection{Design Objectives}

Tor's privacy-enhanced environment introduces distinct challenges to any new infrastructure. Here we enumerate a list of requirements that must be met by any naming system applicable to Tor hidden services. In Section \ref{sec:RelatedWorks} we analyse existing works and show how these systems do not meet these goals and in Section \ref{sec:Solution} we demonstrate how we overcome them with OnioNS.

1. \textbf{Anonymous registrations}: The system should not require any personally-identifiable or location information from the registrant. Tor hidden services publicize no more information than a public key and a set of Introduction Points.

2. \textbf{Privacy-enhanced queries}: Clients should be anonymous, indistinguishable, and unable to be tracked by name servers. Tor already tunnels most Internet DNS queries over circuits, thus any alternative naming system should continue to preserve user privacy during lookups.

3. \textbf{Strong integrity}: Clients must be able to verify that the domain-address pairing that they receive from name servers is authentic relative to the authenticity of the hidden service. This objective provides a defence against phishing attacks.

4. \textbf{Globally unique domain names}: Any domain name of global scope must point to at most one server. For naming systems that generate names via cryptographic hashes, the key-space must be of sufficient length to resist cryptanalytic attack. Unique domain names prevent fragmentation of users and also provides a defence against phishing attacks.

5. \textbf{Distributed control}: Central authorities carry absolute control over the system and root security breaches can easily compromise the integrity of the entire system. They may also be able to compromise the privacy of both users and hidden services or may not allow anonymous registrations.

6. \textbf{High usability}: Most Tor users are not security experts or have technical backgrounds. The system must resolve protocols with minimal input from the user and hide non-essential details.

7. \textbf{Optional}: Not all hidden services require meaningful names. For example, applications such as Ricochet \cite{RicochetGithub} may create ephemeral hidden services where names may not be appropriate or necessary. Thus a naming system should be optional but not required. Systems that provide backwards compatibility by preserving the Tor hidden service protocol also achieve this property.

8. \textbf{Lightweight}: In most realistic environments clients have neither the bandwidth nor storage capacity to hold the system's entire database, nor the capability of meeting significant computation burdens. The system should have a minimal impact on Tor clients and hidden services.

\subsection{Challenges}

\subsubsection{Zooko's Triangle}
\label{sec:ZookosTriangle}

In 2001, Zooko Wilcox-O'Hearn described three desirable properties for any persistent naming system: distributed design, assignment of human-meaningful names, and globally unique names. In a statement now known as Zooko's Triangle, \cite{ferdous2009security, stiegler2005petname} he claimed any naming system could only achieve two of these properties. This is illustrated in Figure \ref{fig:ZookosTriangle}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.3\textwidth]{../assets/images/Zooko.eps}
	\caption{Zooko's Triangle.}
	\label{fig:ZookosTriangle}
\end{figure}

Some examples of naming systems that achieve only two of these properties include:

\begin{itemize}
	\item \textbf{Securely unique and human-meaningful} \\ --- Internet domain names.
	\item \textbf{Decentralized and human-meaningful} \\ --- Human names and nicknames.
	\item \textbf{Securely unique and decentralized} \\ --- PGP keys and Tor .onion addresses.
\end{itemize}

\subsubsection{Authenticated Denial-of-Existence}
\label{sec:authDenialIntro}

When a client queries a name server for a name, the server may respond in three distinct ways:

\begin{enumerate}
	\item It may return the correct destination.
	\item It may return a spoofed destination.
	\item It may claim that an existing name does not exist.
	\item It may choose not to answer.
\end{enumerate}

Cases two and three may be expected by a malicious name server and constitute significant threats to the client. On the Internet, the second case is addressed with SSL certificates and a chain of trust to root Certificate Authorities (CAs) but the third case is not addressed by DNS and remains a possible attack vector. DNSSEC includes an extension for Hashed Authenticated Denial of Existence (NSEC3) which provides signed non-existence claims on a per-domain basis. However, DNSSEC has not seen widespread use, storing per-domain denial-of-existence records introduces significant storage requirements, and to our knowledge no alternative DNS provides mechanisms for authenticated denial-of-existence. Closing this attack vector is not easy; the na\"{i}ve solution of generating proof individually or en-masse for every non-existent domain is infeasible since the domain space is likely too large to practically enumerate.

\section{Related Works}
\label{sec:RelatedWorks}

Vanity key generators (e.g. Shallot \cite{KatmagicShallot}) attempt to find by brute-force an RSA key that generates a partially-desirable hash. Vanity key generators are commonly used by hidden service operators to improve the recognition of their hidden service, particularly for higher-profile services. For example, a hidden service operator may wish to start his service's address with a meaningful noun so that others may more easily recognize it. However, these generators are only partially successful at enhancing readability because the size of the domain key-space is too large to be fully brute-forced in any reasonable length of time. If the address key-space was reduced to allow a full brute-force, the system would fail to be guaranteed collision-free. Nicolussi suggested changing the address encoding to a delimited series of words, using a dictionary known in advance by all parties \cite{nicolussi2011human}. While Nicolussi's encoding improves the readability of an address, like vanity key generators it does not allow addresses to be completely meaningful.

The Internet DNS is already well established as a fundamental abstraction layer for Internet routing. However, despite its widespread use and extreme popularity, the Internet DNS suffers from several significant shortcomings and fundamental security issues that make it inappropriate for use by Tor hidden services. Generally speaking, the Internet DNS by default does not use any cryptographic primitives. DNSSEC is primarily designed to prevent forgeries and DNS cache poisoning from intermediary name servers and it does not provide any degree of query privacy \cite{wachs2014censorship}. Additional extensions and protocols such as DNSCurve \cite{bernstein2009dnscurve} have been proposed, but DNSSEC and DNSCurve have not yet seen widespread full deployment across the Internet. Cachin and Samar \cite{cachin2004secure} extended the Internet DNS and decreased the attack potential for authoritative name servers via threshold cryptography, but the lack of default security in the Internet DNS and the logistical difficulty in globally implementing their work prevents us from using their system for hidden services.

OnionDNS \cite{scaife2015oniondns} is a seizure-resistant alternative resolution service for the Internet. OnionDNS is based on DNS and uses unmodified BIND client software but anonymizes the root server by hosting it as a hidden service. While OnionDNS is highly usable and provides DNSSEC and other authentication mechanisms, the system is centralized by a single root server and thus highly vulnerable if the root is malicious or is compromised. OnionDNS and OnioNS were named independently and readers should take care to not confuse the two works.

The GNU Name System \cite{wachs2014censorship} (GNS) is a decentralized alternative DNS. GNS distributes names across a hierarchical system of zones constructed into directed graphs. Each user manages their own zone and distributes zone access peer-to-peer within social circles. However, GNS does not guarantee that names are \emph{globally} unique. Furthermore, the selection of a trustworthy zone to use would be a significant challenge for using GNS for Tor hidden services and such a selection no longer makes the system distributed. Awerbuch and Scheideler, \cite{awerbuch2004group} constructed a distributed peer-to-peer naming system, but like GNS, made no guarantee that domain names would be globally unique.

Namecoin \cite{NamecoinHome} is an early fork of Bitcoin \cite{nakamoto2008bitcoin} and is noteworthy for achieving all three properties of Zooko's Triangle. Namecoin holds information transactions in a distributed ledger known as a blockchain. Transactions and information are added to the head of the blockchain by ``miners,'' who solve a proof-of-work problem to generate the next block. While Namecoin is often advertised as capable of assigning names to Tor hidden services, it has several practical issues that make it generally infeasible to be used for that purpose. First, Namecoin does not provide a mechanism for proving ownership of domain names; this makes it difficult for a client to prove that the owner of the hidden service private RSA key also maintains the Namecoin secp256k1 ECDSA private key. Second, Namecoin generally requires users to pre-fetch the blockchain which introduces significant logistical issues due to high bandwidth, storage, and CPU load. Third, although Namecoin supports anonymous ownership of information, it is non-trivial to anonymously purchase Namecoins, thus preventing domain registration from being truly anonymous. These issues prevent Namecoin from being a practical alternative DNS for Tor hidden services.

% todo: explain why the SPV or whatever clients don't work, or include OnionDNS's criticisms. This might not be necessary.

\section{Assumptions and Threat Model}
\label{sec:threatModel}

We assume that Tor circuits provides privacy and anonymity; if Alice constructs a three-hop Tor circuit to Bob with modern Tor cryptographic protocols and sends a message $ m $ to Bob, we assume that Bob can learn no more about Alice than the contents of $ m $. This implies that if $ m $ does not contain identifiable information, Alice is anonymous from Bob's perspective. This also implies an assumption on the security of cryptographic primitives and a lack of backdoors or analogous breaks in cryptographic libraries. The security of Tor circuits is also dependent on the assignment of consensus weight; we assume that the majority of directory authorities are at least semi-honest and that consensus weight is an effective defence against Sybil attacks. The aforementioned assumptions are shared by the Tor network.

We assume that an active attacker, Mallory, controls some percentage of dishonest colluding Tor routers as well as semi-honest routers, however this percentage is small enough to avoid violating our second assumption. We assume a fixed percentage of dishonest and semi-honest routers; namely that the percentage of routers under an Mallory's control does not increase in response to the inclusion of OnionNS into Tor infrastructure. This assumption simplifies our threat model analysis but we consider it realistic because while Tor traffic is purposely secret as it travels through the network, we consider OnioNS information public so we don't consider the inclusion of OnioNS a motivating factor to Mallory. However, we allow Mallory to operate and actively MITM any of the non-authoritative name servers.

% Let $ R $ be a set of Tor routers with the Fast, Stable, and Running flags and let $ \mathit{qc} \in R $ be the set of agreeing routers with the largest cumulative amount of consensus weight. If an $ M $-sized set $ Q $ is randomly chosen from $ \mathit{qc} $ with selection probability determined by the consensus weight of each member in $ \mathit{qc} $, then we assume that the largest subset of agreeing routers in $ Q $ are at least semi-honest.

% We assume no upper-bound on the computational capabilities of any adversary, with the exception that they are unable to compromise cryptographic primitives. However, we assume that the adversary has a fixed budget, namely that they have a quota on the memory and CPU hours that they can allocate against our system. We also assume that an adversary may run operate any of the non-authoritative name servers.

% Finally, we assume that all participants in our system -- innocent hidden services as well as adversaries -- operate under some fixed budget, namely that they have an economical or time quota on the memory and CPU resources that they can allocate against our system. We also assume that an adversary may run operate any of the non-authoritative name servers.

% We further assume that an adversary may try to gain control of authoritative OnioNS servers through a Sybil attack on the Tor network or that they may 

As hidden services require no more than a configured Tor client and a socket listener and are thus cheap to create, we anticipate that actors in our system will perform any of the following use cases:

\begin{enumerate}
	\item \textbf{Create many hidden services to register many names.}
	\item \textbf{Create one hidden service to register many names.}
	\item \textbf{Create many hidden services to register a single name.}
	\item \textbf{Create one hidden service to register a single name.}
\end{enumerate}

Scenarios one and two are expected to be performed by adversaries attempting to register all popular names in a ``land rush'' for financial gain or as a denial-of-registration attack. Scenario three may indicate an attempt by many legitimate actors to claim a highly desirable name, while scenario four is the expected behavior of innocent actors. As hidden services are anonymous by nature, it is not straightforward to construct a system that differentiates and selects between a single actor performing the first scenario and many actors performing the fourth scenario. However, as well-known hidden services cannot change their public key, we expect innocent actors to follow the fourth use case.

\section{Solution}
\label{sec:Solution}

\subsection{Cryptographic Primitives}
\label{sec:cryptoPrimitives}

OnioNS utilizes hash functions, digital signature algorithms, a proof-of-work scheme, and a global source of randomness.

\begin{itemize}
	\item Let $ \mathcal{H}(x) $ be a cryptographic hash function. We define $ \mathcal{H}(x) $ as SHA-384.
	\item Let $ S_{\mathit{RSA}}(m, r) $ be a RSA digital signature function that accepts a message $ m $ and a private RSA key $ r $ and returns a digital signature. Let $ S_{\mathit{RSA}}(m, r) $ use $ \mathcal{H}(x) $ as a digest function on $ m $ in all use cases. We define $ S_{\mathit{RSA}}(m, r) $ as EMSA4/EMSA-PSS.
	\item Let $ V_{\mathit{RSA}}(m, R) $ validate an RSA digital signature by accepting a message $ m $ and a public key $ R $, and return true if and only if the signature is valid.
	\item Let $ \mathrm{PoW}(k) $ be a one-way function that accepts an input key $ k $ and returns a deterministic output. We suggest the scrypt \cite{percival2012scrypt} key derivation function with a fixed salt.
	\item Let $ \mathcal{G}(t) $ be a cryptographically-secure generator of random or pseudorandom timestapped numbers. $ \mathcal{G}(t) $ deterministically returns a value for time $ t $ in the present or past.
	\item Let $ \mathcal{R}(s) $ be a pseudorandom number generator that accepts an initial seed $ s $ and returns a list of pseudorandom numbers. In our design, $ s = \mathcal{G}(t) $, so $ \mathcal{R}(s) $ does not need to be cryptographically secure. We suggest MT19937, commonly known as the Mersenne Twister. This generator is widely used throughout most programming languages and is well known for its speed, long period, and the high quality of its pseudorandom output \cite{matsumoto1998mersenne}.
\end{itemize}

\subsection{Definitions}

\textbf{domain name} The syntax of OnioNS domain names mirrors the Internet DNS; we use a sequence of name-delimiter pairs with a .tor pseudo-TLD. The Internet DNS defines a hierarchy of administrative realms that are closely tied to the depth of each name. By contrast, OnioNS makes no such distinction; we let hidden service operators claim second-level names and then control all names of greater depth under that second-level name.

A \textbf{ticket} is a small and fundamental data structure. It contains $ \mathit{type} $, $ \mathit{name} $, $ \mathit{contact} $, $ \mathit{rand} $, $ \mathit{signature} $, and $ \mathit{pubHSKey} $. Tickets by default have $ \mathit{type} $ set to ``ticket'', but this data structure becomes a \textbf{record} if $ \mathit{type} $ is set to any of the operations described in section \ref{sec:recordOps}.

A \textbf{mirror} is Tor router that is acting as a name server within the OnioNS network. Mirrors maintain a textual database of system information and respond to client queries but usually do not accept new DNS records or other information from hidden services. We note that mirrors may be outside the Tor network, but this scenario is outside the scope of this work.

\textbf{Quorum candidates} are mirrors that provide proof in Tor's consensus documents that they hold a current copy of the database and that they have sufficient CPU and bandwidth capabilities to handle OnioNS communication in addition to their normal Tor duties.

The \textbf{Quorum} is authoritative subset of Quorum candidates who have active responsibility over the OnioNS database. Quorum nodes accept and process information from hidden services but do not respond to client queries. The Quorum is randomly chosen from the set of Quorum candidates and is rotated periodically, as described in section \ref{sec:protocols}.

\begin{center}
	\vspace{0mm}
	\begin{table}[htp]
		\hspace{5 mm}
  		\begin{tabular}{ | c | l | }
			$ L_{Q} $ & size of the Quorum \\ \hline
			$ L_{T} $ & number of routers in the Tor network \\ \hline
			$ Q_{i} $ & the $ i $th Quorum where $ i $ is an iteration counter \\ \hline
			$ \Delta q $ & lifetime of the Quorum \\ \hline
			$ r(f) $ & if $ r $ is a record, the field $ f $ in $ r $ \\ \hline
			$ \left\vert{S}\right\vert $ & the cardinality of the set $ S $ \\
		\end{tabular}
		\caption{Frequently used notation.}
	\end{table}
	\vspace{-12mm}
\end{center}

% We also define frequently used notation. Let $ L_{Q} $ be the size of the Quorum, $ L_{T} $ the number of routers in the Tor network, and $ Q_{i} $ as the $ i $th Quorum where $ i $ is an iteration counter. Let the Quorum have have a lifetime of $ \Delta q $ days.

\subsection{Infrastructure}

We embed OnioNS infrastructure within the Tor network by utilizing existing Tor nodes as hosts for OnioNS mirrors. Each Tor node may opt to run a hidden services which then powers a OnioNS mirror running on localhost. As these hidden services are part of OnioNS, they must be accessed by their traditional .onion address, but this is acceptable as these servers are never accessed directly by end-users. Our reliance on hidden services allows us to recycle existing TLS links between Tor nodes and leverage Tor circuits to obscure all communication between end-users and OnioNS infrastructure without requiring a modification to the Tor executable. In essence, all communication with or within OnioNS is hidden from outside observers by ephemeral internal Tor circuits that need not pass through exit routers, increasing privacy and reducing our attack surface.

We authenticate servers in our infrastructure using Ed25519 \cite{bernstein2012high} keys; as of Tor 0.2.7, Tor routers generate and manage Ed25519 keypairs and include their public key in the network consensus. We use Ed25519 because of its strength, size, and speed advantages over Tor's original RSA-1024 identity keys. OnioNS servers provide proof-of-knowledge of their private Ed25519 key for all outbound traffic on their hidden service, achieving end-to-end authentication of all OnioNS communication. Throughout the remainder of this paper, ``hidden services'' refers exclusively to hidden services that are not part of the OnioNS infrastructure.

Each mirror maintains two distinct databases; ``main'' and ``ephemeral'', which both contain records. Newly received records are temporarily stored in the ephemeral database, which is periodically merged into the main database. Mirrors use their main database to respond to clients, who can then authenticate the responses against information published by Quorum nodes. Quorum nodes maintain an additional and secret database that contains lottery tickets.


%Mirrors return records from this database to clients, who can then use the published state to authenticate the mirror's responses, as described in section \ref{sec:authDenial}. 
% Twelve hours prior to the rotation of the Quorum, mirrors merge the ephemeral database into the authenticated database and publish the new state of the authenticated database in the network consensus, as described in section \ref{sec:qQualification}.

%nuance: repeated information is not replayed
% some Q members could be malicious, how are subscriptions handled?

% mention Merkle tree?
% overview of protocols and database management?

\subsection{Protocols}
\label{sec:protocols}

We now describe the protocols fundamental to OnioNS functionality.% These protocols are listed according to their approximate order of execution in OnioNS.

% provide timeline or summary here?

\subsubsection{Random Number Generation}
\label{sec:rngProcess}

We use $ \mathcal{G}(t) $ as a basis for several of our protocols, although we note that $ \mathcal{G}(t) $ has applications in Tor beyond OnioNS. One straightforward definition of $ \mathcal{G}(t) $ is the SHA-384 hash of Tor's consensus documents. If the Tor network is dynamic enough to provide significant amounts of entropy into the consensus documents, then $ \mathcal{G}(t) $ may be considered cryptographically secure. However, this assumption does not hold because current router descriptors are publicly available before the consensus documents are published, allowing $ \mathcal{G}(t) $ under this approach to be easily manipulated by a few malicious Tor routers. The attack becomes significantly easier in the final moments before the directory authorities publish the consensus.

Instead, we suggest implementing $ \mathcal{G}(t) $ as the commitment scheme proposed by Goulet and Kadianakis \cite{GouletCommitReveal}. Their algorithm modifies the consensus voting protocol that is run once an hour by Tor directory authorities. In their scheme, at 00:00 UTC each authority commits a SHA-256 hash of a secret value $ v $ into each consensus vote across a 12 hour period. Then at 12:00 UTC, each directory authority reveals $ v $ across the next set of 12 consensuses. Then at 24:00 UTC, the revealed values are hashed together to create a single random number, which is then embedded in the consensus documents so that it is efficiently distributed to both Tor routers and clients. A different random number thus appears in the consensus every 24 hours. While this implementation of $ \mathcal{G}(t) $ defines $ t $ as an integer of 24 hours, $ \Delta q $ may be greater than 24 hours, as discussed in \ref{sec:qRotation}. Therefore, throughout the remainder of this document we will use the notation $ \mathcal{G}(i) $ to reference the $ \mathcal{G}(t \dot 24 \cdot \Delta q) $ that defines $ Q_{i} $.

%todo: need image here to explain the cycle and Quorum lifetime

The two time boundaries in this implementation of $ \mathcal{G}(t) $ trigger events within our system. The publication of $ \mathcal{G}(i) $ at midnight defines the selection of the next Quorum, causes all mirrors to publish the state of their database, marks the beginning of the next lottery, and determines the winners of the previous lottery. The first reveal at 12:00 UTC ends the lottery and contains the pool of Quorum candidates. We clarify our distinction of these boundaries in section \ref{sec:GlobalRand}. 

% todo: verify that these timings are reflected in the below protocols

\subsubsection{Authenticated Denial-of-Existence}
\label{sec:authDenial}

We described in section \ref{sec:authDenialIntro} that a malicious name server may forge a response or may falsely claim non-existence of a name. These are attack vectors that remain open by naming systems that do not provide authentication mechanisms. We use a Merkle tree \cite{merkle1988digital} to defend against these attacks with minimal networking costs. This tree is a fundamental authentication mechanism for both existing and non-existing names. All mirrors, including Quorum nodes, perform this algorithm. The tree's root hash is then checked by clients during other protocols.

\begin{enumerate}
	\item Charlie fills an array list $ S $ with the $ r_{i}(\mathit{name}) \concat \mathcal{H}(r_{i}) $ for each record $ r_{i} $ received from hidden services.
	\item Charlie sorts $ S $ by the $ \mathit{name} $ field.
	\item Charlie constructs a Merkle tree $ T $ from $ S $.
	\item Charlie publishes the root hash of $ T $ in the consensus as described in section \ref{sec:qQualification}.
\end{enumerate}

We note that a sorted Merkle tree does not support dynamic record updates and must be rebuilt at each update. While other data structures exist that support proof of existence and non-existence and allow efficient updates, such as a skip list \cite{goodrich2001implementation}, these structures are significantly more complicated. We consider it sufficient to use a Merkle tree as the tree is only rebuilt once per day in $ \mathcal{O}(n \log(n) $ time.

%As the \mathit{name} field of each Record is globally unique, we may reference each Record by its \mathit{name}, which saves space. The Merkle tree also 

% As Records contain both second-level domains and their subdomains, $ T $ needs only contain $ c $ to reference all domains in $ r $, which further saves space. Then during a Domain Query Alice may use $ T $ to authenticate a domain $ d $ and verify non-existence for a Record $ r $. The Merkle tree also prevents phishing attacks from Charlie; the tree allows Alice to verify the mappings in $ r $ and the uniqueness of $ d $. The signatures from the Quorum allow her to verify the tree's authenticity. Quorum nodes maintaining identical Pages will sign the same Merkle tree root, so Alice needs to obtain only one subtree and the root signatures by every Quorum node from Charlie.

%Quorum nodes must also periodically regenerate and resign the Merkle tree described in \ref{sec:authDenial} and send the signature to all Quorum nodes and to all subscribers.

% The Quorum must regenerate $ T $ every $ \Delta T $ hours to include new Records. Then Alice needs only fetch the signatures on $ T $ at least every $ \Delta T $ hours to ensure that she can authenticate new Records during the Domain Query. Thus $ \Delta T $ is the primary factor in the speed of Record propagation: Alice cannot authenticate or verify denial-of-existence claims on Records newer than $ \Delta T $. Alice must also fetch the $ L_{Q} $ signature from all Quorum nodes and assert that $ T $ is signed by the largest set of nodes maintaining the same Page, in correspondence with our security assumptions.

\subsubsection{Quorum Qualification}
\label{sec:qQualification}

Quorum candidates must prove that they are both up-to-date mirrors and that they have sufficient capabilities to handle the increased communication and processing demands from OnioNS protocols, an additional burden on top of their traditional Tor responsibilities.

The na\"{i}ve solution to demonstrating the first requirement is for all participants to simply ask mirrors for their internal database, and then compare the recency of its database against the databases from the other mirrors. However, this solution does not scale well; Tor has $ \approx $ 2.1 million daily users \cite{TorMetrics}: it is infeasible for any single node to handle queries from all of them. Instead, at 00:00 UTC each day, let each mirror merge the ephemeral database into the main database, recompute the Merkle tree, and place the root hash inside the Contact field of its router descriptor so that the hash appears in the network consensus. The Contact field is typically used to hold the email address and PGP fingerprint of the router's administrator, but our use of the Contact field allows us to distribute the hash without modifying Tor infrastructure. Mirrors should also distribute their hidden service address in the same way. %These values could also be held in new descriptor fields, which we will explore after publication.

Tor provides a mechanism for demonstrating the latter requirement; Quorum candidates must have the Fast, Stable, and Running flags. Tor routers with higher CPU or bandwidth capabilities relative to their peers also receive a proportionally larger consensus weight from the directory authorities. This consensus weight in turn strongly influences router selection during circuit construction: routers with higher weights are more likely to be chosen in a circuit. This scheme also increases Tor's resistance to Sybil attacks. Thus, we can benefit from this infrastructure by selecting the Quorum from the pool of Quorum candidates by a similar mechanism.

\subsubsection{Quorum Formation}
\label{sec:qFormation}

Mirrors and Tor clients can check the aforementioned qualifications to locally derive the current or any previous Quorum in $ \mathcal{O}(L_{T}) $ time locally without performing any network queries. Without loss of generality, let a client Alice run this algorithm. Alice must download consensus documents from some source, however these documents are timestamped and signed by Tor directory authorities and thus may be retroactively authenticated regardless of where they are archived.

\begin{enumerate}
	\item Alice obtains and validates two consensus documents: $ C_{a} $, which is published at 00:00 UTC and contains $ \mathcal{G}(i) $; and $ C_{b} $, which is the document published 12 hours prior to $ C_{a} $. 
	\item Alice constructs a list $ S $ from $ C_{b} $ of Quorum candidates that have the Fast, Stable, and Running flags.
	\item For each group $ g \in S $ that publishes an identical root hash, Alice computes $ s_{g} = \sum_{j=0}^{\left\vert{g}\right\vert} w_{g}(j) $ where $ w_{g}(j) $ is the consensus weight of Tor router $ j $ in group $ g $. The Quorum candidates, $ \mathit{qc} $, is the group with the largest value of $ s_{g} $.
	\item Alice uses $ \mathcal{R}(\mathcal{G}(i)) $ to select $ \min(\mathrm{size}(\mathit{qc}), L_{Q}) $ Quorum nodes from $ \mathit{qc} $ with the probability of selecting router $ x $ determined by 
	\[
			P(x) = \frac{w_{\mathit{qc}}(x)}{s_{\mathit{qc}}}
	\]
\end{enumerate}

\subsubsection{Database Selection}

Database updates are usually done in near real-time in a peer-to-peer fashion. At startup, OnioNS mirrors subscribe to new information by opening authenticated circuits to the Quorum and attempting to read from the circuit. All Quorum nodes subscribe to each other, forming a complete graph. Assuming that all mirrors are online and at least semi-honest, all mirrors will be processing the same ephemeral and main databases. However, some mirrors may drop offline temporarily or new ones may appear on the network, and these must synchronize with the network to update their databases. Mirrors select certain Quorum nodes to synchronize against by the following algorithm. Let Charlie be a mirror.

% todo: enough detail here?
\begin{enumerate}
	\item Charlie asks each Quorum node for $ \mathcal{H}(\mathit{db}_{e}) $ and $ \mathcal{H}(\mathit{db}_{m}) $, where $ \mathit{db}_{e} $ and $ \mathit{db}_{m} $ is the node's ephemeral and main databases, respectively.
	\item Charlie finds the largest group, $ g $, of Quorum nodes that return the same hashes.
	\item Charlie downloads $ \mathit{db}_{e} $ and $ \mathit{db}_{m} $ from any node in $ g $.
	%\item Charlie verifies that $ \mathcal{H}(\mathit{db}_{e}) $ and $ \mathcal{H}(\mathit{db}_{m}) $ match the $ g $'s hashes.
	\item Charlie verifies the integrity of all records.
	\item Charlie merges and $ \mathit{db}_{e} $ and $ \mathit{db}_{m} $ into his locally-stored $ \mathit{db}_{e} $ and $ \mathit{db}_{m} $.
\end{enumerate}

Quorum nodes that were temporarily offline conduct the same algorithm, but may also ask other Quorum nodes to replay new tickets so that they may update that database too. Non-Quorum mirrors subscribe to Quorum nodes according to the same algorithm.

% When hidden services transmit information to the Quorum, each Quorum node replays it to all subscribers. This allows all Quorum members to receive the same information even if the hidden service transmits to only some Quorum nodes.

\subsubsection{Ticket Generation}
\label{sec:ticketGeneration}

A hidden service operator, Bob, may enter into the OnioNS lottery by generating a ticket, containing a second-level domain name for his hidden service. The Quorum verifies the validity of his ticket and it may be further checked by mirrors and clients if his ticket wins the lottery, so Bob must follow this protocol to ensure that his ticket is accepted by all parties.

\begin{enumerate}
	\item Bob sets \emph{type} to ``ticket''.
	\item Bob sets \emph{name} to a meaningful domain name.
	\item Bob sets \emph{subdomains} to a map of domains of level three or higher and their respective destinations, which may be to either .tor or .onion domains.
	\item Bob optionally sets \emph{contact} to his PGP key fingerprint.
	\item Bob sets \emph{rand} to $ \mathcal{G}(i) $.
	\item Bob sets \emph{signature} as the output of $ S_{\mathit{RSA}}(\mathit{type} \concat \mathit{name} \concat \mathit{subdomains} \concat \mathit{contact} \concat \mathit{rand}, r) $ where $ r $ is Bob's private RSA key.
	\item Bob saves his RSA public key in \emph{pubHSKey}.
\end{enumerate}

Bob's ticket is valid when $ \mathrm{PoW}(\mathit{signature}) \leq t_{d} $ where $ t_{d} $ is a difficulty threshold set by Quorum nodes. Each iteration of $ \mathrm{PoW}(\mathit{signature}) $ results in a different and one-way output because $ S_{\mathit{RSA}}(m, r) $ is a probabilistic signature scheme. Bob must repeatedly resign and recompute scrypt until the formula is satisfied. Once this is the case, Bob sends his ticket to all Quorum nodes.

\subsubsection{Ticket Processing}

A Quorum node $ Q_{i,k} $ listens for tickets from hidden service operators. When a ticket $ t $ is received, $ Q_{i,k} $

\begin{enumerate}
	\item Rejects $ t $ if $ t $ is not valid according to the protocol described in section \ref{sec:ticketGeneration}.
	\item Rejects $ t $ if $ t $'s \emph{name} already exists in its lottery, ephemeral, or main databases.
	\item Rejects $ t $ if the hidden service does not have a descriptor in Tor's distributed hash table.
	\item Rejects $ t $ if the hidden service cannot answer an HTTP GET request.
	% \item Rejects $ t $ if the response from an HTTP GET matches any other response from previous tickets.
	\item Otherwise, it accepts $ t $, records $ t $ in its lottery database, and sends $ t $ to all other Quorum nodes.
\end{enumerate}

\subsubsection{Lottery Management}
\label{sec:lotteryManagement}

In section \ref{sec:ticketGeneration} we describe a proof-of-work (PoW) protocol that acts as a barrier-of-entry. It is straightforward to design a system where a name is awarded after the completion of this PoW; however such a system is vulnerable to attacks by adversaries with strong computational capabilities who may quickly register many names, as we described in section \ref{sec:threatModel}. In an attempt to resolve this problem, we introduce a lottery-like system, managed by Quorum nodes.

The lottery starts at the formation of the Quorum. During the lottery, the Quorum accepts requests (or ``tickets'') for names for hidden services, creating a list $ T_{i} $. The lottery ends when $ Q_{i} $ is cycled to $ Q_{i + 1} $. At this time, each node in $ Q_{i} $ performs the following algorithm. Let Charlie $ \in Q_{i} $.

\begin{enumerate}
	\item Charlie publishes $ T_{i} $ to all subscribers.
	\item Charlie uses $ \mathcal{R}(\mathcal{G}(i + 1)) $ to select a list of winners, $ W_{i} $, from $ T_{i} $. 
	\item Charlie merges $ W_{i} $ into his main database, letting them receive names.
\end{enumerate}

All mirrors or other parties may verify $ W_{i} $ and update their main database accordingly through the same protocol because $ T_{i} $ is now public. As this algorithm occurs at 00:00 UTC, mirrors then update their Merkle root hash per the protocol described in section \ref{sec:qQualification}.

In order to defend against the one-to-many and many-to-one attacks described in section \ref{sec:threatModel}, each Quorum node only accepts the first ticket per hidden service and the first ticket per name. We provide a defense to the many-to-many attack by setting the proof-of-work threshold $ t_{d} $ according to the formula $ d_{b} / \ceil{\frac{j}{\nWinners}} $, where $ d_{b} $ is the base difficulty and $ j $ is the ticket's index, $ 1 \leq i \leq \nWinners $.

%Quorum ends when G(t+1) is actually published. 
%
%All reveals available so G(t) can be calculated
%G(t) first revealed
%
%or Quorum rotation - 1 day, then G(t) first revealed?

% accept only first for pubKey and first for name

% However, an attacker who is not a dirauth should not be able to influence the outcome at all.

% The reveal phase lasts 12 hours, and most authorities will send their reveal value on the first round of the reveal phase. This means that an attacker can predict the final shared random value about 12 hours before it's generated.

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.4\linewidth]{../assets/images/LucidCharts/Page-chain2.pdf}
%	\caption{THIS IS A PLACEHOLDER IMAGE. TODO: create diagram of lottery-results timeline. The responsibilities of each Quorum are divided into two distinct parts: first, a lottery period where ``tickets'' are accepted and recorded; and second, a naming period where a fixed number of applicants receive names. The beginning of the Quorum and the lottery coincides with the publication of $ \mathcal{G}(t) $ in the consensus (section \ref{sec:rngProcess}) while the beginning of the naming period corresponds to the appearance of $ \mathcal{G}(t) $ by the directory authorities.}
%	\label{fig:lotteryTimeline}
%\end{figure}

\subsubsection{Record Operations}
\label{sec:recordOps}

% todo: I'd like to remove PoW from records, but then how would clients verify that the work was done? Would they get the original ticket too?
% at the current or original PoW difficulty? How is this handled? -maybe unnecessary detail

OnioNS also supports common operations on names. Owners of named hidden services may construct modify, renew, transfer, or delete records and issue the records to the Quorum. Once received, mirrors add these records to their ephemeral database. These records can be send to and authenticated by clients within 24 hours, as mirrors merge their ephemeral database into their main database and update their Merkle root publication at 00:00 UTC every day. In all cases, Bob sets the \emph{type} field to the appropriate record type.

Bob can modify his registration by changing either his \emph{subdomains} or \emph{contact} fields. Bob may also transfer the registration to a new owner by issuing a transfer record, which contains \emph{recipientKey}, the public RSA key of the new hidden service. Bob may also relinquish control of his name by issuing a delete record. Bob does not need to recompute proof-of-work for any of these records as these operations are cheap for the Quorum to apply. However, OnioNS names expire after 30 days, so name owners must periodically renew registrations to maintain ownership. This can be done by issuing a renew ticket with an updated $ \mathcal{G}(i) $ and recalculating the proof-of-work algorithm.

%todo: analysis: non-winners will likely try again. Won't this impact the PoW-difficulty adjustment?

\subsubsection{Domain Query}

Alice only needs Bob's ticket or his latest record to contact Bob by his meaningful name. She then uses the Merkle tree structure to verify that her name server responds with the correct ticket or record, or to achieve authenticated denial-of-existence if her query has no corresponding data structure. Let Alice type a domain $ d $ into the Tor Browser.

\begin{enumerate}
	\item Alice contacts a name server Charlie via his hidden service.
	\item \label{step:ask} Alice asks Charlie for a ticket or record $ r $ containing $ d $.
	\item Charlie extracts the second-level name $ n $ from $ d $.
	\item If $ r $ exists, Charlie returns $ r $, the leaf node containing $ n $, and all the nodes from the leaf to the root and their sibling nodes.
	\item If $ r $ does not exist, Charlie returns two adjacent leaves $ a $ and $ b $ (and the nodes on their paths and siblings) such that $ a(\mathit{name}) < n < b(\mathit{name}) $, or in the boundary cases that $ a $ is undefined and $ b $ is the left-most leaf or $ b $ is undefined and $ a $ is the right-most leaf.
	\item Alice verifies the authenticity or non-existence of $ r $ by 
		\begin{enumerate}
			\item Asserting that $ n $ is either contained in the subtree or that $ n $ is spanned by the subtree leaves, respectively.
			\item Asserting the correctness of the hashes in the subtree.
			\item Asserting that the root hash matches the hash published by the largest agreeing set of Quorum nodes. %todo: does this last bit match database inheritance?
		\end{enumerate}
	\item If these assertions fail, Alice knows that Charlie is dishonest and she must repeat this protocol with a different mirror.
	\item If $ d $ in $ r $ points to a domain $ d_{2} $ which has a .tor pseudo-TLD, Alice jumps to \ref{step:ask} and queries for $ d_{2} $.
	\item Alice computes Bob's .onion address from $ r(\mathit{pubHSKey}) $ and contacts him in the hidden service protocol.
\end{enumerate}

While Alice can verify the authenticity and uniqueness of $ r $ by synchronize against the OnioNS network and downloading the database from the Quorum, but this is impractical in most environments. Tor's median circuit speed is often less than 4 Mbit/s, \cite{TorMetrics} so for the sake of convenience data transfer must be minimized. Therefore Alice can simply fetch minimal information and rely on her existing trust of members of the Tor network.

\subsubsection{Onion Query}

OnioNS also supports reverse-hostname lookups. In an Onion Query, Alice issues a hidden service address \emph{addr} to Charlie and receives back all Records that have \emph{addr} as either the owner or as a destination in their \emph{subdomain}. Alice may obtain additional verification on the results by issuing Domain Queries on the source .tor domains. We do not anticipate Onion Queries to have significant practical value, but they complete the symmetry of lookups and allow OnioNS domain names to have Forward-Confirmed Reverse DNS matches. We suggest caching destination hidden service addresses in a digital tree (trie) to accelerate this lookup; a trie turns the lookup from $ \mathcal{O}(n) $ to $ \mathcal{O}(1) $, while requiring $ \mathcal{O}(n) $ time and $ \mathcal{O}(n) $ space to pre-compute the cache.

% The idea here is that although everyone gets a proportionally-higher increase in PoW difficulty, it's acceptable by innocent parties (an extra 36 minutes is not that much) but the attacker now has to spend 48 hour of CPU (18 more hours) to get 30 tickets. If the attacker has a fixed budget for 30 hours of CPU time he'll be unable to make 30 tickets in lottery 3, but rather only 30/1.6=18. The difficulty never decreases, so if the number of tickets in the lottery is blinded from everyone except the Quorum, a point will be reached where the statistics are no longer in the attacker's favor, leading him to conclude that it's no longer worth it.

%\setlength{\belowcaptionskip}{-10pt}

% infrastructure (Authorative servers) (server management), registration process

%\subsection{Overview}
%
%We propose the Onion Name System (OnioNS) as an abstraction layer to hidden service addresses and introduce ``.tor'' as a new pseudo-TLD for this purpose.
%
% First, Bob generates and self-signs a \emph{Record}, containing a meaningful second-level domain name and his public key $ \mathcal{P}_{B} $. Without loss of generality, let this be ``example.tor $ \rightarrow $ onions55e7yam27n.onion''. We introduce a proof-of-work scheme that requires Bob to expend computational and memory resources to claim ``example.tor''; the protocol allows Bob to claim a meaningful name in a distributed environment while remaining anonymous. Proof-of-work systems are noteworthy for their asymmetry: they require the issuer to spend effort to find an answer to a moderately hard computational problem, but once solved can be easily verified correct by any recipient. The requirement of proof-of-work fulfils three main purposes:
%
%\begin{enumerate}
%	\item Significantly reduces the threat of DoS flood attack.
%	\item Introduces a barrier-of-entry that encourages the utilization of domain names and the availability of the underlying hidden services.
%	\item Increases the difficulty of domain squatting.
%\end{enumerate}
%

\section{Security Analysis}
\label{sec:Analysis}

In this section, we analyse the security of the Onion Name System with regard to our security goals and expected threat model. 

\subsection{Global Randomness}
\label{sec:GlobalRand}

We implement $ \mathcal{G}(t) $ using \cite{GouletCommitReveal}. Commitment protocols have been studied in other works \cite{rivest1999unconditionally, naor1990bit} and are well understood. If all parties are at least semi-honest then the commitment protocols generally display correctness, privacy, and binding. However, if some participants are malicious, they demonstrate known weaknesses. Namely, while reveals must demonstrably match commits, each participant may choose to reveal or not. If they do not reveal, their value is lost and the protocol produces a different output. If Mallory controls $ b $ participants, she can make this choice with each participant in turn, allowing $ 2^{b} $ different outcomes.

\cite{GouletCommitReveal} relies on nine directory authorities, which are maintained by prominent members of the Tor community. The security of the Tor network rests on the assumption that five or more are at least semi-honest, thus their commitment scheme has at most $ 2^{4} = 16 $ different outcomes in the worst case without violation of our assumptions. Given the statistical calculations and the safety margin introduced by the recommendations in section \ref{sec:qSize}, we do not consider this a significant threat to our system and conclude that the Quorum Formation protocol is secure under our design assumptions. The unpredictability of the reveals and the low probability of compromise shown in Figures \ref{fig:quorumWeightedMajority} and \ref{fig:cumulativeProbability} provides the strongest defense against Quorum-level attacks.

% In their scheme, at 00:00 UTC each authority commits a SHA-256 hash of a secret value $ x $ into each consensus vote across a 12 hour period. Then at 12:00 UTC, each directory authority reveals $ x $ across the next set of 12 consensuses. Then at 24:00 UTC, the revealed values are hashed together to create a single random number, which is then embedded in the consensus documents so that it is efficiently distributed to both Tor routers and clients.

Assuming that all directory authorities reveal at 12:00 UTC, the design of \cite{GouletCommitReveal} allows $ \mathcal{G}(i) $ to be calculated up to 12 hours before $ \mathcal{G}(i) $ is published in the consensus. If we select $ Q_{i} $ from the 00:00 UTC consensus containing $ \mathcal{G}(i) $, an adversary could calculate $ \mathcal{G}(i) $ to add or remove routers from the consensus in order to deterministically inject malicious routers into $ Q_{i} $. As a countermeasure, the protocol in section \ref{sec:qFormation} selects the Quorum from the consensus containing the first set of reveals.

\subsection{Integrity Guarantees}

Merkle trees are widely used to achieve secure verification of very large data structures. They are an integral component in the ZFS file system, Bitcoin, \cite{nakamoto2008bitcoin} Apache's Cassandra NoSQL database, \cite{CassandraDatabase} and in many other applications. The security of the Merkle tree largely rests on the underlying hash function and its resistance to second pre-image attacks. During a domain query, clients fetch a subtree from mirrors, verify the integrity of the ticket or record against the leaf node, and recompute and verify the hashes of the subtree. The cryptographic strength of SHA-384 prevents mirrors from forging or falsely claiming non-existence of a ticket or record. Clients also check the subtree value against the Quorum's published hashes, preventing mirrors from forging the subtree or returning an obsolete subtree. This approach provides strong integrity guarantees for both existent and non-existent records even if the mirror is malicious.

\subsection{Proof-of-Work}
\label{sec:proofOfWork}

% The proof-of-work formula is satisfied when $ \mathrm{PoW}(S_{\mathit{RSA}}(c, r)) \leq t_{d} $, where $ c $ is static data. 

We integrated the proof-of-work step into our registration protocols in order to create a barrier-of-entry, with the expectation that Bob run the scrypt function himself. However, our algorithm does not entirely prevent Bob from outsourcing this expensive computation to a secondary computational resource, Frank, whom we assume does not have the private key $ r $. 

First, Bob repeatedly computes $ S_{\mathit{RSA}}(c, r) $, producing a large list of digital signatures. Frank then tests $ \mathrm{PoW}(x) \leq t_{d} $ for each digital signature $ x $ until the formula is satisfied. Bob then sets the ticket's $ \mathit{signature} $ field to this $ x $ value, producing a valid ticket. Bob can minimize the size of his precomputed list by sending each signature individually to Frank for testing. However, as scrypt is an purposely computationally-expensive function, this still incurs a cost upon Frank that must be financially compensated by Bob. Thus, the algorithm always introduces a cost to Bob.

Alternative algorithms may more tightly couple the scrypt and RSA-PSS components and prevent Bob from outsourcing the proof-of-work step. However, we are unaware of any existing algorithm that combines proof-of-work with digital signatures. The next generation of Tor hidden services \cite{TorProp224} replaces RSA-1024 keys with Ed25519; in future work we will explore whether the Ed25519 deterministic signature scheme may be tightly combined with scrypt. 

\subsection{Lottery}
\label{sec:lottery}

Our lottery uses proof-of-work as a barrier-of-entry and awards names to a fixed number of hidden services to limit abuse. However, adversaries with significant computational capabilities may still register many tickets in order to improve their chances of winning the lottery. This may be done as part of a denial-of-registration attack or an en-mass registration strategy. By contrast, we anticipate that honest hidden services will only attempt to register a single name, therefore they may be assumed to be computationally weak. We consider this dichotomy when selecting the lottery's initial parameters.

Our lottery has a high degree of usability if it awards names a very large number of hidden services. Although this increases its vulnerability to the aforementioned attacks from computationally-powerful adversaries, we introduce several straightforward countermeasures. First, we may preload OnioNS with a large set of ``reserved'' names by constructing a mapping between popular hidden services and their self-declared name. Although these pre-existing hidden services must still generate a lottery ticket, they win names immediately. This both increases the usability of our system and removes a significant incentive for land rush attacks. Second, we demonstrate that a large number of winners and the lottery's difficultly-adjustment scheme provides a statistical defense against well-resourced adversaries.

As described in section \ref{sec:lotteryManagement}, the $ Q_{i} $ sets the proof-of-work threshold, $ t_{d} $, according to 

\begin{equation}
	t_{d} = \frac{d_{b}}{\ceil{\frac{j}{\nWinners}}}
\end{equation}

\noindent where $ d_{b} $ is the base difficulty, $ W_{i} $ is the set of lottery winners, and $ j $ is the ticket's index in $ W_{i} $. If $ \nWinners $ innocent parties submit tickets, then by the partial sum formula Craig (a computationally-powerful adversary) must perform 

\begin{equation}
	C_{w} = \frac{d_{b} \cdot \nWinners \cdot n \cdot  (n+1)}{2} - d_{b} \cdot \nWinners
	\label{eq:CraigWork}
\end{equation}

\noindent amount of work to have a $ \frac{1}{n} $ chance of his names winning the lottery. In the same scenario, if Craig is $ X $ times computationally stronger than the average capabilities of the innocent parties, he may compute $ C_{t} $ number of lottery tickets, where

\begin{equation}
	C_{t} = \frac{-3 \cdot d_{b} \cdot \nWinners + d_{b} \cdot \nWinners \sqrt{9 + \frac{8X}{\nWinners}}}{2}
	\label{eq:nCraigTickets}
\end{equation}

If his tickets are also submitted to $ Q_{i} $, then the expected number of winning innocent tickets is given by

\begin{equation}
	\left\vert{W_{i}(\mathrm{innocent})}\right\vert = \frac{2 \nWinners}{-1 + \sqrt{9 + \frac{8X}{\nWinners}}}
	\label{eq:expInnocentWinners}
\end{equation}

Craig could also generate many tickets in order to statistically prevent others from winning the lottery. However, this also becomes impractical for large $ \nWinners $: if Equation \ref{eq:expInnocentWinners} is set to 1, then $ X $ is given by 

\begin{equation}
	X = \frac{\nWinners^{3} + \nWinners^{2}}{2} - \nWinners
	\label{eq:resistance2DoR}
\end{equation}

$ C_{w} $ increases quadratically to $ \nWinners $, suggesting that large values for $ \nWinners $ act as a defense against a denial-of-registration attack; with large $ \nWinners $ it is impractical for Craig to generate many tickets in order to increase the proof-of-work difficulty beyond the means of innocent parties. However, large $ \nWinners $ also allows Craig to claim or squat many names. Bared on the above equations, we recommend awarding more than 21 names per lottery and suggest $ \nWinners = 35 $. We note that this value is adjustable and can be easily increased to meet a demonstrably higher demand from the Tor community.

We must also select a value for $ d_{b} $. Low values for $ d_{b} $ provides a low barrier-to-entry, increasing usability, but it also increases the lottery's vulnerability to attacks from Craig. We consider that Craig that has access to efficient cloud computation, such as Amazon EC2. A compute-optimized instance, such as c4.large in California, costs appropriately 1 USD for 11 CPU core-hours on an Intel Xeon E5-2666 processor. In Table \ref{table:PoWtime}, we use \href{https://www.cpubenchmark.net/}{cpubenchmark.net} to convert this to the equivalent quantity of computation from a selection of Intel i7 CPUs, which are commonly found in high-end consumer-grade computers.

% , which will be accepted as long as $ \mathit{rand} $ is updated to the $ \mathcal{G}(i) $

We anticipate that innocent hidden services with high-end CPUs will take less than five or six hours to generate a lottery ticket. Even with lower-end CPUs, fewer utilized cores, or a higher difficulty, the proof-of-work algorithm will generate a valid ticket eventually. It may be possible to lower the difficulty if we can prevent innocent hidden services from outsourcing computation by more tightly coupling proof-of-work to a digital signature algorithm. Finally, we suggest doubling the difficulty every two years so as to keep pace with a global average increase in computational power.

With a sufficiently high value of $ \nWinners $ and a significant value for $ d_{b} $, we believe that our lottery can resist a well-resourced adversary while simultaneously serving computationally-weak innocent parties.

\begin{center}
	\vspace{0mm}
	\begin{table}[htp]
		\hspace{5 mm}
  		\begin{tabular}{ | c | c | c | c | c | }
  		\textbf{CPU} & \textbf{Speed} & \textbf{vCPUs} & \textbf{CPU Hours} & \textbf{Wall Time} \\ \hline
  		c4.large & 24804 & 2 & 11 & 7.33 \\ \hline
  		i7-5960X	 & 16002 & 16 & 17.05 & 1.42 \\ \hline
  		i7-5930K & 13666 & 12 & 19.96 & 2.21 \\ \hline
  		i7-4930K & 13074 & 12 & 20.87 & 2.32 \\ \hline
  		i7-3930K & 12080 & 12 & 22.58 & 2.51 \\ \hline
  		i7-4790K & 11228 & 8 & 24.30 & 4.05 \\ \hline
  		i7-6700K & 11028 & 8 & 24.74 & 4.12 \\ \hline
  		i7-4790 & 10034 & 8 & 27.19 & 4.53 \\ \hline
  		i7-6700 & 9962 & 8 & 27.38 & 4.56 \\
		\end{tabular}
		\caption{The average time to complete the proof-of-work across various computational resources. These CPUs utilize hyper-threading; we assume that a single vCPU provides 75 percent of the power of a real core.}
		\label{table:PoWtime}
	\end{table}
	\vspace{-10mm}
\end{center}

%Selecting the number of winners in our lottery requires balancing the demand from innocent requests for names against the threat of en-mass registrations by adversaries. If the number of winners is too low, it is too difficult for innocent HS operators to claim a name. On the other hand, too many winners allows computationally-powerful domain squatters to claim many names. Both scenarios negatively impact the usability of our system. While it is difficult to accurately predict honest demand for our system, we can estimate it by examining the number of popular hidden services on the Tor network.

% As $ T_{i} $ is initially blinded, it is difficult for the adversary to determine in advance if this threshold is reached. This scheme also means that the system adapts in response to an increase in global average computational speed as the barrier-of-entry becomes too low.

\subsection{DNS Leakage}

Accidental leakage of .tor lookups over the Internet DNS via human mistakes or misconfigured software may compromise user privacy. This vulnerability is not limited to OnioNS and applies to any pseudo-TLD; Mohaisen and Thomas observed .onion lookups on root DNS servers at a frequency that corresponded to external global events and highlighting the human factor in those leakages \cite{thomasmeasuring}. Closing this leakage is difficult; arguably the simplest approach is to introduce whitelists or blacklists into common web browsers to prevent known pseudo-TLDs from being queried over the Internet DNS. Such changes are outside the scope of this work, but we highlight the potential for this leak.


%We require no personally-identifiable information in domain registration and client queries are stateless and indistinguishable. We protect all communication into and inside OnioNS with Tor circuits, further enhancing user privacy. Our use of the Merkle tree provides strong integrity guarantees. The network as a 

%routers with high consensus weight must maintain high uptime, therefore we can assume that they all agree. This is also a good assumption since routers that are temporarily offline resynchronize when they come online again.

%Second, registrations are authenticable, which can be reduced to the security of the Merkle hash tree and to the assumption that the largest subset of Quorum nodes are honest. We verify this assumption in section \ref{sec:QSelection} and \ref{sec:qSize}. Domain uniqueness also stems from the above assumption, relying on honesty of Quorum nodes to avoid collisions. Quorum selection is a random process assuming security of the commitment algorithm run by the directory authorities, which we analyse in section \ref{sec:RandGeneration}. 

\section{Evaluation}
\label{sec:Evaluation}

\subsection{Implementation}

We have build a reference implementation of the Onion Name System in C++11 as a supplement to this work. We utilize Boost Asio \cite{AsioLib} for our networking engine and use the Botan \cite{BotanLib} library for most cryptographic operations. We encode all the data structures in JSON; JSON is significantly more compact than XML, but retains user readability and its support of basic primitive types is highly applicable to our needs. Since JSON is usually not capable of carrying binary values, we encode all non-ASCII values (such as SHA-384 hashes) in base64. Our code is licensed under the Modified BSD License, identical to Tor, and is available for Linux through a software repository at our hidden service, \href{http://onions55e7yam27n.onion}{http://onions55e7yam27n.onion}.

We divided our software into three parts: OnioNS-client, OnioNS-server, and OnioNS-HS, with OnioNS-common as a shared library dependency. OnioNS-client negotiates with the user's Tor software to MitM all requests for torified TCP streams. It filters for our .tor pseudo-TLD while allowing all other lookups (IPv4, .onion, or DNS) to pass unimpeded. Once it intercepts a request for a .tor domain, it performs a Domain Query and rewrites the domain to a .onion address before allowing Tor to bind the request to a circuit. This approach preserves backwards-compatibility, achieving a design objective and enhancing usability. The OnioNS-server is comparatively simpler; it binds to a localhost TCP port and performs our protocols. Tor router administrators must then configure their Tor to host a hidden service and bind it to the same localhost port so that OnioNS-server may be reached from the outside. Finally, OnioNS-HS is a simple command-line utility that prompts the user for domain information, performs the proof-of-work, and uploads the ticket or record to the current Quorum. In all three cases, our software functions with minimal configuration.

\subsection{Integration Test}

We have deployed a small testing network of Quorum and mirror servers. We first created a hidden service for our project, set up a small web server, and used Shallot to generate a semi-meaningful address, \href{http://onions55e7yam27n.onion}{``onions55e7yam27n.onion''}. We then used OnioNS-HS to create a lottery ticket for ``example.tor'' and then to transmit it to the Quorum. This sole ticket won the lottery and we received our name. Our ticket then propagated through the network to mirrors. Finally, we installed our client software into Tor Browser 5.5, a fork of Firefox 38.4.0 ESR. We typed ``example.tor'' into the Tor Browser and the request was intercepted, resolved through a Domain Query, and rewritten to \href{http://onions55e7yam27n.onion}{``onions55e7yam27n.onion''}. The Tor binary then communicated with our hidden service and returned the contents back to the Tor Browser. This process did not require any further user input and occurred behind-the-scenes, so the Tor Browser retained the ``example.tor'' name in the address bar and in the mouse-over text for relative hyperlinks. We illustrate the result in Figure \ref{fig:prototypeExample}. The software performed asynchronously and allowed normal browsing to both the Internet and other hidden services while it resolved ``example.tor''.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{../assets/images/example.png}
	\caption{We load the OnioNS' hidden service, \href{http://onions55e7yam27n.onion}{``onions55e7yam27n.onion''}, transparently under the ``example.tor'' domain. The OnioNS software launches with the Tor Browser.}
	\label{fig:prototypeExample}
\end{figure}

\subsection{Results}

\subsubsection{Performance}

We tested the performance of our OnioNS-HS and OnioNS-client software on two machines, $ M_{a} $ and $ M_{b} $. $ M_{a} $ contains an Intel Core2 Quad Q9000 (Penryn architecture) 2.00 GHz CPU from late 2008 and $ M_{b} $ an Intel i7-2600K (Sandy Bridge architecture) 4.3 GHz CPU from 2011, representing low-end and medium-end consumer-grade computers, respectively. Both machines were hosted on a 1 Gbit connection on a university campus.

We selected the parameters of scrypt such that it consumed 128 MB of RAM during operation. We consider this an affordable amount of RAM for low-end consumer-grade computers. OnioNS-common provides a multi-threaded implementation of the Ticket Generation protocol, so OnioNS-HS used all eight virtual CPUs on $ M_{b} $ to generate the ticket. As expected, RAM consumption scaled linearly with the number of scrypt instances executed in parallel; with eight cores we observed that the software consumed approximately 1 GB of RAM.

Following ticket generation, we then measured the performance of OnioNS-client. We averaged 200 samples of the CPU wall-time required for both machines to validate the ticket.

\renewcommand{\arraystretch}{1.3}
\newcolumntype{L}[1]{>{\hsize=#1\hsize\raggedright\arraybackslash}X}%
\newcolumntype{R}[1]{>{\hsize=#1\hsize\raggedleft\arraybackslash}X}%
\newcolumntype{C}[2]{>{\hsize=#1\hsize\centering\arraybackslash}X}%
\begin{table}[h]
	\small
	\begin{tabularx}{\linewidth}{ | C{1} || C{1} || C{1} || }
    	\textbf{Description} & \textbf{A (ms)} & \textbf{B (ms)} \\ \hline
    	Parsing JSON & 5.21 & 2.42 \\ \hline
		Validating scrypt & 448.184 & 294.963 \\ \hline
		$ V_{\mathit{RSA}}(m, E) $ & 6.35 & 2.74 \\ \hline
		Total Time & 459.744 & 300.123 \\
  	\end{tabularx}
\end{table}

$ M_{b} $ outperformed $ M_{a} $ in all instances and we observed that single iteration of scrypt dominated the total validation time, matching our expectations. Obviously, higher-end CPUs can complete an iteration of scrypt in less time, but nevertheless the proof-of-work is the largest source of CPU cost for clients, mirrors, and Quorum nodes. Although we anticipate that this is an acceptable load on all parties, clients on extremely limited hardware may elect to skip the proof-of-work verification step at the cost of some security.

\subsubsection{Latency}

Although Tor is a low-latency network, all communications occur over six-hop hidden service paths through Tor, which introduces latency into most of our protocols. The exact time is highly dependent on the speed of the routers selected by either party. The latency is most significant for clients and adds an additional delay between the time that a user enters an OnioNS domain into the Tor Browser and the moment that Tor begins loading the hidden service. Fortunately, latency and load times across Tor circuits have been well studied. 

% S_{M} = \log_{64}(2 \cdot \log_{2}(Z)) + e \cdot \log_{2}(Z)
Domain Queries transfer a record/ticket and a Merkle subtree. We expect that a ticket or record would be less than 1 KiB. If OnioNS contains $ Z $ names, then the expected byte size of the serialized Merkle subtree, $ S_{M} $, is approximated by
\[
S_{M} = 2 \cdot (\log_{64} 2^{384} + e) \cdot \log_{2} Z
\]
\noindent where $ e $ represents markup and other formatting overhead in the transmission. Our implementation has $ e \approx 16 $ so if $ Z $ is 8192, then the expected networking cost for clients is $ 1872 + 1024 = 2896 $ bytes, or 2.83 KiB. While Tor provides measurements on the performance of Tor circuits, their smallest measurement is 50 KiB, which we illustrate in Figure \ref{fig:latencyGraph}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{../assets/images/torperf_50kb_2015-02_2015-08.eps}
	\caption{The average performance to download 50 KiB files over Tor circuits, as measured by Tor bandwidth authorities. The first and third quartiles are shown with the median time shown in orange \cite{TorMetrics}.}
	\label{fig:latencyGraph}
\end{figure}

The client can avoid most of the latency overhead of hidden service communication (path negotiation and circuit construction) by building a single tunnel to a mirror at startup and then recycling it for all subsequent queries. The client also needs to fetch the $ C_{a} $ and $ C_{b} $ consensus documents which are needed to derive the Quorum and verify the Merkle root, but this can also be done at startup. We therefore believe that we will have less than 50 ms of latency overhead for most queries.

Our implementation also provides a client-side cache which resolves queries locally whenever possible. This prevents redundant queries to remote mirrors and slightly reduces the ability for mirrors to track the popularity of hidden services.

\subsubsection{Usability}

OnioNS is lightweight for clients, is straightforward for hidden service operators to use, and is easy for Tor router administrators to support. Our client software integrates well into the Tor Browser and starts and stops with the Tor Browser environment. As shown in Figure \ref{fig:prototypeExample}, OnioNS resolves and loads hidden services under a meaningful name transparently without requiring any user interaction, similar to traditional DNS requests over Tor circuits. Domain Queries have low latency and the local cache can further reduce overhead, which is especially helpful if cached records are part of a chain of resolutions. 

OnioNS-HS enables hidden service operators to claim a name and locally manage record information. The Ticket Generation protocol has minimal prompts: it asks the user for the main domain name, a list of subdomains and destinations, and an optional PGP key. It then loads the hidden service private key, performs the proof-of-work algorithm, and automatically uploads the ticket to the Quorum. We released a beta test of our software to Tor developers and volunteers and received positive feedback on the simplicity of the registration process.

We achieve another primary usability benefit by introducing an automatic naming system for Tor hidden services: it is no longer necessary for the Tor community to construct and maintain directories of hidden services. The automatic resolution of domain names allows scaling beyond human-maintained directories. OnioNS should provide a significant usability enhancement to Tor users and the community at large.

\subsection{Discussions}

In this section we further discuss and compare our work with related works. The Onion Name System and Namecoin both achieve all three properties of Zooko's Triangle and share some similarities, but the two systems have different threat models and distinct design objectives.

Namecoin's security rests on two primary assumptions: that its network is resistant to Sybil attacks and that more than 50 percent of the network's computational power is at least semi-honest. An attacker that controls the majority of the computational power (a ``51\% attack'') or that has carried out a successful Sybil attack may then disrupt communications, corrupt the integrity of the blockchain, or can provide malicious responses to clients. Namecoin, like Bitcoin, also usually requires that clients download a complete copy of the blockchain. This introduces significant network, storage, and CPU costs which grow linearly to the age and popularity of the Namecoin network, preventing Namecoin from scaling to the general population. These costs can be largely avoided if the client uses a Namecoin-compatible DNS server or a Simplified Payment Verification \cite{nakamoto2008bitcoin} (SPV) scheme. These approaches are vulnerable to a variety of attacks if the name server is malicious and neither approach provides authenticated denial-of-existence.

By contrast, OnioNS' central security assumption is that Tor circuits provide privacy. This assumption implies that the majority of the directory authorities remain semi-honest and that Tor network remains resistant to Sybil attack and traffic analysis. We rely on these assumptions for all aspects of our system. Thus, we can use existing Tor infrastructure instead of introducing a new network, as Namecoin does. Moreover, if an attacker can compromise Tor circuits or de-anonymize hidden services, then a privacy-enhanced naming system no longer becomes necessary or relevant. Unlike Namecoin, we do not rely on assumptions of computational power; while Craig can negatively impact the ability for innocent hidden services to get a name, he cannot affect the security of OnioNS or disrupt network communications. Our system remains secure as long as the Quorum remains uncompromised and we demonstrate in the appendix that a sufficiently-large Quorum is strongly resistant to a Sybil attack on the Tor network.

OnioNS has significantly less overhead than Namecoin: our database can be modified or deleted in-place, mirrors only remember records for non-expired names, and the storage requirements for clients is constant. Instead, the client receives a Merkle subtree and checks the root against a single consensus document. The storage cost is therefore linear to the size of the Tor network and the networking cost is logarithmic to the number of registered names. The Merkle tree provides authenticated denial-of-existence and prevents a malicious server from acting dishonestly.

OnioNS and Namecoin both allow full enumeration of all registered domains; however we do not consider this a significant threat to our system as registrations do not contain personal information. Both systems operate under weaker adversarial models than GNS, which assumes than attacker may participant in any role, may infiltrate the network by large-scale Sybil attack, and is assumed to have more computational power than all honest participants combined. Neither Namecoin, OnioNS, nor Tor provide full defenses against such well-resourced adversaries. Tor hidden services may become de-anonymized under GNS' adversarial model so we do not assume that our adversaries are that powerful. %End-users should select their naming system carefully according to their threat model.

\section{Conclusions and Future Work}

We have presented the Onion Name System (OnioNS), a distributed, secure, and usable alternative DNS that maps globally-unique and meaningful names to hidden service addresses, achieving all three properties of Zooko's Triangle. We enable any hidden service operator to anonymously claim a human-readable name for their server and clients to query the system in privacy-enhanced manner. We introduce mechanisms that let clients authenticate existent names and denial-of-existence claims with minimal overhead costs. Additionally, we utilize the existing and semi-trusted infrastructure of Tor, which significantly narrows our threat model to already well-understood attack surfaces and allows our system to be integrated into Tor with minimal effort. Our reference implementation demonstrates high usability and shows that OnioNS successfully addresses the major usability issue that has been with Tor hidden services since their introduction in 2002.

Following publication, we will expand our implementation and pursuit deploying it onto the Tor network. OnioNS introduces new software and a new .tor pseudo-TLD but requires no changes to the Tor executable. OnioNS is also forwards-compatible to changes in Tor circuits or the hidden service protocol and requires only small modifications to become compatible to \cite{TorProp224}, the proposed next generation of Tor hidden services.

%Additionally, our implementation currently only supports ASCII characters in domain names, so in future work we will explore implementing Punycode to provide support for international character sets. Unlike the Internet DNS, we will disallow digits zero and one (similar to base32 encoding) in order to reduce the threat of phishing attacks from spoofed domains with indistinguishable characters.

%\section{Acknowledgements}

%We would like to thank Roger Dingledine, George Kadianakis, Yawning Angel, and Nick Mathewson for their support, %commentary, and assistance with Tor technical support.

%%We would like to thank Tor developers and volunteers within the community for technical support and their commentary on our work.
%
%%, a password-based key derivation function which is notable for its large memory and CPU requirements during its operation. The scrypt function provides significantly greater resistance to custom hardware attacks and massively parallel computation primarily due to its memory requirements. This limits attackers to the same software implementation and asymptotic cost as legitimate users\cite{percival2009stronger}\cite{percival2012scrypt}. We choose scrypt because of these advantages over other key derivation functions such as SHA-256 or PBKDF2. For these reasons scrypt is also common for proof-of-work purposes in some cryptocurrencies such as Litecoin.
%
%% ----------------------------------------------------------------------------------------
%
%% An example of a floating figure using the graphicx package.
%% Note that \label must occur AFTER (or within) \caption.
%% For figures, \caption should occur after the \includegraphics.
%% Note that IEEEtran v1.7 and later has special internal code that
%% is designed to preserve the operation of \label within \caption
%% even when the captionsoff option is in effect. However, because
%% of issues like this, it may be the safest practice to put all your
%% \label just after \caption rather than within \caption{}.
%%
%% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
%% option should be used if it is desired that the figures are to be
%% displayed while in draft mode.
%%
%%\begin{figure}[!t]
%%\centering
%%\includegraphics[width=2.5in]{myfigure}
%% where an .eps filename suffix will be assumed under latex, 
%% and a .pdf suffix will be assumed for pdflatex; or what has been declared
%% via \DeclareGraphicsExtensions.
%%\caption{Simulation Results}
%%\label{fig_sim}
%%\end{figure}
%
%% Note that IEEE typically puts floats only at the top, even when this
%% results in a large percentage of a column being occupied by floats.
%
%% ----------------------------------------------------------------------------------------
%
%% An example of a double column floating figure using two subfigures.
%% (The subfig.sty package must be loaded for this to work.)
%% The subfigure \label commands are set within each subfloat command, the
%% \label for the overall figure must come after \caption.
%% \hfil must be used as a separator to get equal spacing.
%% The subfigure.sty package works much the same way, except \subfigure is
%% used instead of \subfloat.
%%
%%\begin{figure*}[!t]
%%\centerline{\subfloat[Case I]\includegraphics[width=2.5in]{subfigcase1}%
%%\label{fig_first_case}}
%%\hfil
%%\subfloat[Case II]{\includegraphics[width=2.5in]{subfigcase2}%
%%\label{fig_second_case}}}
%%\caption{Simulation results}
%%\label{fig_sim}
%%\end{figure*}
%%
%% Note that often IEEE papers with subfigures do not employ subfigure
%% captions (using the optional argument to \subfloat), but instead will
%% reference/describe all of them (a), (b), etc., within the main caption.
%
%% ----------------------------------------------------------------------------------------
%
%% An example of a floating table. Note that, for IEEE style tables, the 
%% \caption command should come BEFORE the table. Table text will default to
%% \footnotesize as IEEE normally uses this smaller font for tables.
%% The \label must come after \caption as always.
%%
%%\begin{table}[!t]
%%% increase table row spacing, adjust to taste
%%\renewcommand{\arraystretch}{1.3}
%% if using array.sty, it might be a good idea to tweak the value of
%% \extrarowheight as needed to properly center the text within the cells
%%\caption{An Example of a Table}
%%\label{table_example}
%%\centering
%%% Some packages, such as MDW tools, offer better commands for making tables
%%% than the plain LaTeX2e tabular which is used here.
%%\begin{tabular}{|c||c|}
%%\hline
%%One & Two\\
%%\hline
%%Three & Four\\
%%\hline
%%\end{tabular}
%%\end{table}

% https://en.wikibooks.org/wiki/LaTeX/Bibliography_Management#Bibliography_styles
\bibliographystyle{amsplain} 
\bibliography{citations}

\section{Appendix}

%In this section we statistically analyse the Tor network and provide recommendations for the size and rotation rate of the Quorum.

\subsection{Quorum Size} % todo
\label{sec:qSize}

In section \ref{sec:threatModel}, we assume that an attacker, Mallory, controls some fixed $ f_{E} $ fraction of routers on the Tor network. Quorum selection may be considered as an $ L_{Q} $-sized random sample taken from an $ L_{T} $-sized population without replacement, where the population contains $ L_{T} \cdot f_{E} $ entities that we assume are compromised and colluding. Then the probability that Mallory controls $ L_{E} $ Quorum nodes is given by the hypergeometric distribution, whose probability mass function is shown in Equation \ref{eq:hypergeoPMF}. Mallory controls the Quorum if either $ > \frac{L_{Q} - L_{E}}{2} $ honest Quorum nodes disagree or if $ L_{E} > \frac{L_{Q}}{2} $. The former scenario is difficult to model theoretically or in simulation, but the probability of the latter may be calculated. If all Quorum nodes are selected with equal probability, then $ \mathrm{Pr}(L_{E} > \frac{L_{Q}}{2}) $ is given by the $p$-value of the hypergeometric test for over-representation, expressed in Equation \ref{eq:compromiseProb}.

% This statistical analysis assumes that OnioNS servers remained synchronized with the rest of the network; however we feel that this assumption is reasonable because the assignment of consensus weight is in part dependent on availability and furthermore that temporarily offline OnioNS servers resynchronize at startup. 

%As we skew Quorum selection by consensus weight, we must also consider Tor's distribution of consensus weight in our analysis and probability estimations.

%The probability that Mallory controls $ L_{E} $ Quorum nodes is given by the hypergeometric distribution, whose probability mass function is shown in Equation \ref{eq:hypergeoPMF}.

\begin{align}
	\mathrm{Pr}(L_{E}) &= \frac{\binom{L_{T} \cdot f_{E}}{L_{E}}\binom{L_{T} - L_{T} \cdot f_{E}}{L_{Q} - L_{E}}}{\binom{L_{T}}{L_{Q}}}
	\label{eq:hypergeoPMF}
	\\
	\mathrm{Pr}(L_{E} > \frac{L_{Q}}{2}) &= \displaystyle\sum_{i=\ceil{\frac{L_{Q}}{2}}}^{L_{Q}} \frac{\binom{L_{T} \cdot f_{E}}{i}\binom{L_{T} - L_{T} \cdot f_{E}}{L_{Q} - i}}{\binom{L_{T}}{L_{Q}}}
	\label{eq:compromiseProb}
\end{align}

Odd choices for $ L_{Q} $ prevents the network from splintering in the event that the Quorum is evenly split across two databases. We provide the statistical calculations of Equation \ref{eq:compromiseProb} for various Quorum sizes in Figure \ref{fig:quorumUnweightedMajority}.




%If all Quorum Candidates have an equal probability of selection, then the probability that $ L_{E} > \frac{L_{Q}}{2} $ is given by the $p$-value of the hypergeometric test for over-representation, expressed in Equation \ref{eq:compromiseProb}. 
%
%We skew Quorum selection by consensus weight, In the next section we estimate the probability of Mallory controlling the Quorum under this weighted selection under Tor's distribution of consensus weight
%
% analyse Tor's distribution of consensus weight and the probability of Mallory controlling the Quorum under this weighted selection.
%
%We also assume that Tor's assignment of consensus weight provides a defence against Sybil attack and thus weight the se we also calcu
%
%The Quorum is rotated every $ \Delta q $ days, so we must consider the implications of selections for both $ L_{Q} $ and $ \Delta q $.

%In section \ref{sec:threatModel}, we assume that an attacker, Mallory, controls some fixed $ f_{E} $ fraction of routers on the Tor network. Quorum selection may be considered as an $ L_{Q} $-sized random sample taken from an $ L_{T} $-sized population without replacement, where the population contains $ L_{T} \cdot f_{E} $ entities that we assume are compromised and colluding. If our selection includes $ L_{E} $ Mallory-controlled routers, then Mallory controls the Quorum if either $ > \frac{L_{Q} - L_{E}}{2} $ honest Quorum nodes disagree or if $ L_{E} > \frac{L_{Q}}{2} $. The former scenario is hard to model theoretically or in simulation, but the probability of the latter can be statistically calculated. The Quorum is rotated every $ \Delta q $ days, so we must consider the implications of selections for both $ L_{Q} $ and $ \Delta q $.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{../assets/analysis/QuorumSelectionUnweighted.eps}
	\caption{The values for $ \mathrm{Pr}(L_{E} > \frac{L_{Q}}{2}) $ for Quorum sizes of 31, 63, 127, 255, and 511. All probabilities exceed 0.5 when more than 50 percent of the Tor network is under Mallory's control. We set our population to 4540 routers; the average number of routers with the Fast, Stable, and Running flags across all consensuses in July 2015 \cite{TorMetrics}.}
	\label{fig:quorumUnweightedMajority}
\end{figure}

However, we select Quorum members according to consensus weight, akin to router selection in a Tor circuit. The distribution of consensus weight (and thus the selection probabilities) for routers with the Fast, Stable, and Running flags closely follows an exponential distribution, as shown in Figure \ref{fig:weightDist}. The figure suggests that the Tor network contains a low number of high-end routers and a large number of low-end routers.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{../assets/analysis/QuorumCandidateWeights.eps}
	\caption{The normalized distribution of consensus weights of Quorum candidates in July 2015, reflecting the probabilities of inclusion in the Quorum. The distribution may be modelled by an exponential trendline with $ R^{2} = 0.9884 $, but appears slightly super-exponential.}
	\label{fig:weightDist}
\end{figure}

We now re-examine Equation \ref{eq:compromiseProb} with regard to this distribution of consensus weight. Consider that the hypergeometric distribution describes the probability of selecting $ k $ Mallory-controlled routers in an $ L_{Q} $-sized Quorum from an $ N $-sized population containing $ K $ Mallory-controlled routers. Let $ L(x) $ be the probability distribution of selecting a router whose consensus weight is at the lowest $ x $ percentile. Then the probability of compromise is given by Equation \ref{eq:compromiseWeighted} where $ K $, the expected number of routers in a population of size $ N $, is given by Equation \ref{eq:compromiseK}, and $ R $ is the probability that routers outside $ L(x) $ are compromised. Since $ L(x) $ describes probabilities and $ N $ must be a natural number, ($ N \in \mathbb{N} $) this approach provides an approximation of the probability of compromise.

We illustrate the probabilities against discrete values of $ x $ and various Quorum sizes in Figure \ref{fig:quorumWeightedMajority} using $ N = 4540 $, consistent with the population in Figure \ref{fig:quorumUnweightedMajority}.

\begin{align}
	K &= N \cdot \left( \int_0^x(L(x)) + R \cdot \int_x^1(L(x)) \right)
	\label{eq:compromiseK}
	\\
	\mathrm{Pr}(L_{E} > \frac{L_{Q}}{2}) &= \displaystyle\sum_{i=\ceil{\frac{L_{Q}}{2}}}^{L_{Q}} \frac{\binom{K}{i}\binom{N - K}{L_{Q} - i}}{\binom{N}{L_{Q}}}
	\label{eq:compromiseWeighted}
\end{align}

In contrast to Figure \ref{fig:quorumUnweightedMajority} which demonstrates that an unweighted selection leads to a high probability of compromise with small levels of collusion, Figure \ref{fig:quorumWeightedMajority} suggests that biasing Quorum selection by consensus weight provides a strong defence against large-scale Sybil attacks. Indeed, even when 60 percent of the low-end Quorum candidates are malicious, most Quorum sizes produce negligible probabilities of compromise. We consider it reasonable to assume that low-end routers are under Mallory's control; these routers are the cheapest and logistically easiest to operate. Our approach remains resistant to this attack: these routers will be included in the Quorum very infrequently because of their low consensus weight.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{../assets/analysis/QuorumSelectionWeighted10.eps}
	\caption{The values for $ \mathrm{Pr}(L_{E} > \frac{L_{Q}}{2}) $ from Equation \ref{eq:compromiseWeighted} for various Quorum sizes. We assume that all routers $ \in L(x) $ are under Mallory's control, while routers $ \notin L(x) $ have a 10 percent chance of being under Mallory's control.}
	\label{fig:quorumWeightedMajority}
\end{figure}

Small Quorums are also more susceptible to node downtime or denial-of-service attacks. Figure \ref{fig:quorumWeightedMajority} shows that the choices of $ L_{Q} = 31 $ is suboptimal; it is more easily compromised even with low levels of collusion. $ L_{Q} = 63 $ is more resistant, but not significantly more so. We therefore recommend $ L_{Q} \geq 127 $.

\subsection{Quorum Rotation} % todo
\label{sec:qRotation}

In section \ref{sec:threatModel}, we assume that $ f_{E} $ is fixed and does not increase in response to the inclusion of OnioNS on the Tor network. If we also assume that $ L_{T} $ is fixed, then we can examine the impact of choices for $ \Delta q $ and calculate the probability of Mallory compromising any Quorum over a period of time $ t $. Mallory's cumulative chances of compromising any Quorum is given by $ 1 - (1 - f_{c})^{\frac{t}{\Delta q}} $ where $ f_{c} $ is Mallory's chances of compromising a single Quorum. We estimate this over 10 years in Figure \ref{fig:cumulativeProbability}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{../assets/analysis/CumulativeMaliciousQuorumNew.eps}
	\caption{The cumulative probability that Mallory controls any Quorum at different rotation rates over 10 years at $ f_{E} = 50 $ for Quorum sizes 31, 63, 127, and 255. We base these statistics on the probabilities from Figure \ref{fig:quorumWeightedMajority} at 50 percent collusion.}
	\label{fig:cumulativeProbability}
\end{figure}

%It also supports our earlier conclusion that the choices of $ L_{Q} = 31 $ and $ L_{Q} = 63 $ are suboptimal.
Figure \ref{fig:cumulativeProbability} suggests that although larger values of $ \Delta q $ positively impact security, the choice of $ L_{Q} $ is more significant. Furthermore, even "Stable" routers in the Tor network may be too unstable for very slow rotation rates, and small values for $ \Delta q $ also reduces the disruption timeline for a malicious Quorum. Therefore, based on Figure \ref{fig:cumulativeProbability}, we further reiterate our recommendation of $ L_{Q} \geq 127 $ and suggest $ \Delta q = 7 $. Although a malicious Quorum would have the capabilities to deploy a variety of attacks on the network, the proper selections of $ L_{Q} $ and $ \Delta q $ reduces the likelihood of this occurring to near-zero probabilities. We consider this a stronger solution than introducing countermeasures to specific Quorum-level attacks.

\subsection{Derivation of Lottery Analysis Equations}

In this section we derive and further clarify the lottery analysis equations that we introduced in section \ref{sec:lottery}. We set the proof-of-work threshold, $ t_{d} $ according to
\[
	t_{d} = \frac{d_{b}}{\ceil{\frac{j}{\nWinners}}}
\]

Thus $ t_{d} = d_{b} $ for the first $ \nWinners $ tickets, $ t_{d} = 2 d_{b} $ for the second set of $ \nWinners $ tickets, and so on. The coefficient is then given by the $ n $th triangular number.
\[
	t(n) = \binom{n + 1}{2} = \frac{n \cdot (n + 1)}{2}
\]

In the scenario in section \ref{sec:lottery}, Craig submits his tickets after $ \nWinners $ innocent actors. Thus Craig starts with $ t_{d} = 2 d_{b} $ and each must compute $ d_{b} \cdot \nWinners $ for each set in the base case.
\begin{align*}
	C_{w} &= d_{b} \cdot \nWinners \cdot (\frac{n \cdot  (n+1)}{2} - 1) \\
	C_{w} &= \frac{d_{b} \cdot \nWinners \cdot n \cdot  (n+1)}{2} - d_{b} \cdot \nWinners
\end{align*}

This is Equation \ref{eq:nCraigTickets}. We can then solve for $ n $. %, the number of tickets that Craig can compute with $ C_{w} $ work.
\begin{align*}
	C_{w} &= d_{b} \cdot \nWinners \cdot (\frac{n \cdot  (n+1)}{2} - 1) \\
	\frac{C_{w}}{d_{b} \cdot \nWinners} &= \frac{n^{2} + n}{2} - 1 \\
	\frac{C_{w}}{d_{b} \cdot \nWinners} + 1 &= \frac{n^{2} + n}{2} \\
	\frac{2 \cdot C_{w}}{d_{b} \cdot \nWinners} + 2 &= n^{2} + n \\
	0 &= n^{2} + n - \frac{2 \cdot C_{w}}{d_{b} \cdot \nWinners} - 2 \\
	n &= \frac{-1 + \sqrt{1 - 4(\frac{-2 \cdot C_{w}}{d_{b} \cdot \nWinners} - 2)}}{2} \\
	n &= \frac{-1 + \sqrt{9 + \frac{8 \cdot C_{w}}{d_{b} \cdot \nWinners}}}{2}
\end{align*}

\newpage

We must then account for the fact that $ \nWinners $ have already been submitted. This produces 
\begin{align*}
	n &= \frac{-1 + \sqrt{9 + \frac{8 \cdot C_{w}}{d_{b} \cdot \nWinners}}}{2} - 1 \\
	n &= \frac{-3 + \sqrt{9 + \frac{8 \cdot C_{w}}{d_{b} \cdot \nWinners}}}{2}
\end{align*}

% I'm less certain about this!
We then multiply by the total cost of generating a set $ \nWinners $ to get Equation \ref{eq:nCraigTickets}.
\begin{align*}
	C_{t} = \frac{-3 \cdot d_{b} \cdot \nWinners + d_{b} \cdot \nWinners \sqrt{9 + \frac{8X}{\nWinners}}}{2}
\end{align*}

The expected number of winning innocent hidden services is the number of winners multiplied by the probability of selecting innocent hidden services.
\begin{align*}
	\left\vert{W_{i}(\mathrm{innocent})}\right\vert &= \frac{\nWinners \cdot \nWinners}{\nWinners \cdot C_{t}} \\
	\left\vert{W_{i}(\mathrm{innocent})}\right\vert &= \frac{\nWinners^{2}}{\nWinners \cdot \frac{-3 \cdot d_{b} \cdot \nWinners + d_{b} \cdot \nWinners \sqrt{9 + \frac{8X}{\nWinners}}}{2}} \\
	\left\vert{W_{i}(\mathrm{innocent})}\right\vert &= \frac{2 \cdot \nWinners^{2}}{-n + n \cdot \sqrt{9 + \frac{8X}{\nWinners}}} \\
	\left\vert{W_{i}(\mathrm{innocent})}\right\vert &= \frac{2 \nWinners}{-1 + \sqrt{9 + \frac{8X}{\nWinners}}}
\end{align*}

This is Equation \ref{eq:expInnocentWinners}. Then we can derive Equation \ref{eq:resistance2DoR} by the following:
\begin{align*}
	1 &= \frac{2 \nWinners}{-1 + \sqrt{9 + \frac{8X}{\nWinners}}} \\
	X &= \frac{\nWinners^{3} + \nWinners^{2}}{2} - \nWinners
\end{align*}


% that's all folks
\end{document}
